// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: talaria.proto

package talaria

import (
	bytes "bytes"
	context "context"
	encoding_binary "encoding/binary"
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	github_com_gogo_protobuf_sortkeys "github.com/gogo/protobuf/sortkeys"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// Batch represents an event batch. It contains a map of strings in order
// to minimize the size.
type Batch struct {
	Strings map[uint32][]byte `protobuf:"bytes,1,rep,name=strings,proto3" json:"strings,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	Events  []*Event          `protobuf:"bytes,2,rep,name=events,proto3" json:"events,omitempty"`
}

func (m *Batch) Reset()      { *m = Batch{} }
func (*Batch) ProtoMessage() {}
func (*Batch) Descriptor() ([]byte, []int) {
	return fileDescriptor_8f344df92059c5ff, []int{0}
}
func (m *Batch) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Batch) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Batch.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Batch) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Batch.Merge(m, src)
}
func (m *Batch) XXX_Size() int {
	return m.Size()
}
func (m *Batch) XXX_DiscardUnknown() {
	xxx_messageInfo_Batch.DiscardUnknown(m)
}

var xxx_messageInfo_Batch proto.InternalMessageInfo

func (m *Batch) GetStrings() map[uint32][]byte {
	if m != nil {
		return m.Strings
	}
	return nil
}

func (m *Batch) GetEvents() []*Event {
	if m != nil {
		return m.Events
	}
	return nil
}

// Event represents a single event. Name as well as value columns are
// interned strings which are present in a batch.
type Event struct {
	Value map[uint32]*Value `protobuf:"bytes,1,rep,name=value,proto3" json:"value,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *Event) Reset()      { *m = Event{} }
func (*Event) ProtoMessage() {}
func (*Event) Descriptor() ([]byte, []int) {
	return fileDescriptor_8f344df92059c5ff, []int{1}
}
func (m *Event) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Event) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Event.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Event) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Event.Merge(m, src)
}
func (m *Event) XXX_Size() int {
	return m.Size()
}
func (m *Event) XXX_DiscardUnknown() {
	xxx_messageInfo_Event.DiscardUnknown(m)
}

var xxx_messageInfo_Event proto.InternalMessageInfo

func (m *Event) GetValue() map[uint32]*Value {
	if m != nil {
		return m.Value
	}
	return nil
}

// Value represents a value
type Value struct {
	// Types that are valid to be assigned to Value:
	//	*Value_Binary
	//	*Value_String_
	//	*Value_Int
	//	*Value_Uint
	//	*Value_Double
	//	*Value_Bool
	Value isValue_Value `protobuf_oneof:"value"`
}

func (m *Value) Reset()      { *m = Value{} }
func (*Value) ProtoMessage() {}
func (*Value) Descriptor() ([]byte, []int) {
	return fileDescriptor_8f344df92059c5ff, []int{2}
}
func (m *Value) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Value) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Value.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Value) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Value.Merge(m, src)
}
func (m *Value) XXX_Size() int {
	return m.Size()
}
func (m *Value) XXX_DiscardUnknown() {
	xxx_messageInfo_Value.DiscardUnknown(m)
}

var xxx_messageInfo_Value proto.InternalMessageInfo

type isValue_Value interface {
	isValue_Value()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type Value_Binary struct {
	Binary uint32 `protobuf:"varint,1,opt,name=binary,proto3,oneof" json:"binary,omitempty"`
}
type Value_String_ struct {
	String_ uint32 `protobuf:"varint,2,opt,name=string,proto3,oneof" json:"string,omitempty"`
}
type Value_Int struct {
	Int int64 `protobuf:"varint,3,opt,name=int,proto3,oneof" json:"int,omitempty"`
}
type Value_Uint struct {
	Uint uint64 `protobuf:"varint,4,opt,name=uint,proto3,oneof" json:"uint,omitempty"`
}
type Value_Double struct {
	Double float64 `protobuf:"fixed64,5,opt,name=double,proto3,oneof" json:"double,omitempty"`
}
type Value_Bool struct {
	Bool bool `protobuf:"varint,6,opt,name=bool,proto3,oneof" json:"bool,omitempty"`
}

func (*Value_Binary) isValue_Value()  {}
func (*Value_String_) isValue_Value() {}
func (*Value_Int) isValue_Value()     {}
func (*Value_Uint) isValue_Value()    {}
func (*Value_Double) isValue_Value()  {}
func (*Value_Bool) isValue_Value()    {}

func (m *Value) GetValue() isValue_Value {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *Value) GetBinary() uint32 {
	if x, ok := m.GetValue().(*Value_Binary); ok {
		return x.Binary
	}
	return 0
}

func (m *Value) GetString_() uint32 {
	if x, ok := m.GetValue().(*Value_String_); ok {
		return x.String_
	}
	return 0
}

func (m *Value) GetInt() int64 {
	if x, ok := m.GetValue().(*Value_Int); ok {
		return x.Int
	}
	return 0
}

func (m *Value) GetUint() uint64 {
	if x, ok := m.GetValue().(*Value_Uint); ok {
		return x.Uint
	}
	return 0
}

func (m *Value) GetDouble() float64 {
	if x, ok := m.GetValue().(*Value_Double); ok {
		return x.Double
	}
	return 0
}

func (m *Value) GetBool() bool {
	if x, ok := m.GetValue().(*Value_Bool); ok {
		return x.Bool
	}
	return false
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*Value) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*Value_Binary)(nil),
		(*Value_String_)(nil),
		(*Value_Int)(nil),
		(*Value_Uint)(nil),
		(*Value_Double)(nil),
		(*Value_Bool)(nil),
	}
}

// IngestRequest represents an ingestion request.
type IngestRequest struct {
	Batch *Batch `protobuf:"bytes,1,opt,name=batch,proto3" json:"batch,omitempty"`
}

func (m *IngestRequest) Reset()      { *m = IngestRequest{} }
func (*IngestRequest) ProtoMessage() {}
func (*IngestRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_8f344df92059c5ff, []int{3}
}
func (m *IngestRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IngestRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IngestRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *IngestRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IngestRequest.Merge(m, src)
}
func (m *IngestRequest) XXX_Size() int {
	return m.Size()
}
func (m *IngestRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_IngestRequest.DiscardUnknown(m)
}

var xxx_messageInfo_IngestRequest proto.InternalMessageInfo

func (m *IngestRequest) GetBatch() *Batch {
	if m != nil {
		return m.Batch
	}
	return nil
}

// IngestResponse represents an ingestion response.
type IngestResponse struct {
}

func (m *IngestResponse) Reset()      { *m = IngestResponse{} }
func (*IngestResponse) ProtoMessage() {}
func (*IngestResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_8f344df92059c5ff, []int{4}
}
func (m *IngestResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IngestResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IngestResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *IngestResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IngestResponse.Merge(m, src)
}
func (m *IngestResponse) XXX_Size() int {
	return m.Size()
}
func (m *IngestResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_IngestResponse.DiscardUnknown(m)
}

var xxx_messageInfo_IngestResponse proto.InternalMessageInfo

func init() {
	proto.RegisterType((*Batch)(nil), "talaria.Batch")
	proto.RegisterMapType((map[uint32][]byte)(nil), "talaria.Batch.StringsEntry")
	proto.RegisterType((*Event)(nil), "talaria.Event")
	proto.RegisterMapType((map[uint32]*Value)(nil), "talaria.Event.ValueEntry")
	proto.RegisterType((*Value)(nil), "talaria.Value")
	proto.RegisterType((*IngestRequest)(nil), "talaria.IngestRequest")
	proto.RegisterType((*IngestResponse)(nil), "talaria.IngestResponse")
}

func init() { proto.RegisterFile("talaria.proto", fileDescriptor_8f344df92059c5ff) }

var fileDescriptor_8f344df92059c5ff = []byte{
	// 419 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x6c, 0x52, 0x4f, 0x6b, 0xd4, 0x40,
	0x14, 0x9f, 0xb7, 0xd9, 0x64, 0xe5, 0xd9, 0x2d, 0x65, 0x28, 0x3a, 0xae, 0x30, 0x84, 0x20, 0x92,
	0xd3, 0x0a, 0xd5, 0x82, 0xd4, 0xdb, 0x42, 0x25, 0xbd, 0x8e, 0xe0, 0x3d, 0xd1, 0x61, 0x0d, 0x86,
	0x49, 0xcd, 0x4c, 0x0a, 0xbd, 0x89, 0x9f, 0xc0, 0x4f, 0xe0, 0xc1, 0x93, 0x1f, 0xc5, 0xe3, 0x1e,
	0x7b, 0x74, 0xb3, 0x17, 0x8f, 0xfd, 0x08, 0x32, 0x33, 0x49, 0xcd, 0xa2, 0xb7, 0xfd, 0xbd, 0xdf,
	0x9f, 0xf7, 0x7b, 0x3b, 0xc1, 0xb9, 0xc9, 0xab, 0xbc, 0x29, 0xf3, 0xe5, 0x65, 0x53, 0x9b, 0x9a,
	0xce, 0x7a, 0x98, 0x7c, 0x07, 0x0c, 0x57, 0xb9, 0x79, 0xf7, 0x81, 0x9e, 0xe2, 0x4c, 0x9b, 0xa6,
	0x54, 0x6b, 0xcd, 0x20, 0x0e, 0xd2, 0xfb, 0x27, 0x8f, 0x97, 0x83, 0xc7, 0x09, 0x96, 0x6f, 0x3c,
	0x7b, 0xae, 0x4c, 0x73, 0x2d, 0x06, 0x2d, 0x7d, 0x8a, 0x91, 0xbc, 0x92, 0xca, 0x68, 0x36, 0x71,
	0xae, 0xc3, 0x3b, 0xd7, 0xb9, 0x1d, 0x8b, 0x9e, 0x5d, 0x9c, 0xe1, 0xc1, 0x38, 0x80, 0x1e, 0x61,
	0xf0, 0x51, 0x5e, 0x33, 0x88, 0x21, 0x9d, 0x0b, 0xfb, 0x93, 0x1e, 0x63, 0x78, 0x95, 0x57, 0xad,
	0x64, 0x93, 0x18, 0xd2, 0x03, 0xe1, 0xc1, 0xd9, 0xe4, 0x25, 0x24, 0x5f, 0x00, 0x43, 0x97, 0x46,
	0x9f, 0x0d, 0x1a, 0x5f, 0xf1, 0xd1, 0xfe, 0xb2, 0xe5, 0x5b, 0xcb, 0xf9, 0x82, 0x5e, 0xb7, 0xc8,
	0x10, 0xff, 0x0e, 0xff, 0xb3, 0xf4, 0xc9, 0x78, 0xe9, 0xb8, 0xbd, 0x73, 0x8d, 0x4b, 0x7c, 0x03,
	0x0c, 0xdd, 0x90, 0x32, 0x8c, 0x8a, 0x52, 0xe5, 0x4d, 0x1f, 0x94, 0x11, 0xd1, 0x63, 0xcb, 0xf8,
	0xff, 0xc5, 0xc5, 0x39, 0xc6, 0x63, 0x4a, 0x31, 0x28, 0x95, 0x61, 0x41, 0x0c, 0x69, 0x90, 0x11,
	0x61, 0x01, 0x3d, 0xc6, 0x69, 0x6b, 0x87, 0xd3, 0x18, 0xd2, 0x69, 0x46, 0x84, 0x43, 0x36, 0xe3,
	0x7d, 0xdd, 0x16, 0x95, 0x64, 0x61, 0x0c, 0x29, 0xd8, 0x0c, 0x8f, 0xad, 0xbe, 0xa8, 0xeb, 0x8a,
	0x45, 0x31, 0xa4, 0xf7, 0xac, 0xde, 0xa2, 0xd5, 0xac, 0xbf, 0x20, 0x39, 0xc5, 0xf9, 0x85, 0x5a,
	0x4b, 0x6d, 0x84, 0xfc, 0xd4, 0x4a, 0x6d, 0xec, 0x6d, 0x85, 0x7d, 0x39, 0x57, 0x73, 0x7c, 0x9b,
	0x7b, 0x4f, 0xe1, 0xc9, 0xe4, 0x08, 0x0f, 0x07, 0x9b, 0xbe, 0xac, 0x95, 0x96, 0x27, 0xaf, 0x71,
	0x76, 0xa1, 0xd6, 0x8d, 0xd4, 0x9a, 0xbe, 0xc2, 0xc8, 0x93, 0xf4, 0xc1, 0x9d, 0x7b, 0x6f, 0xc9,
	0xe2, 0xe1, 0x3f, 0x73, 0x9f, 0x92, 0x90, 0xd5, 0x8b, 0xcd, 0x96, 0x93, 0x9b, 0x2d, 0x27, 0xb7,
	0x5b, 0x0e, 0x9f, 0x3b, 0x0e, 0x3f, 0x3a, 0x0e, 0x3f, 0x3b, 0x0e, 0x9b, 0x8e, 0xc3, 0xaf, 0x8e,
	0xc3, 0xef, 0x8e, 0x93, 0xdb, 0x8e, 0xc3, 0xd7, 0x1d, 0x27, 0x9b, 0x1d, 0x27, 0x37, 0x3b, 0x4e,
	0x8a, 0xc8, 0x7d, 0xa1, 0xcf, 0xff, 0x04, 0x00, 0x00, 0xff, 0xff, 0x3f, 0x1f, 0x82, 0x34, 0xb2,
	0x02, 0x00, 0x00,
}

func (this *Batch) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Batch)
	if !ok {
		that2, ok := that.(Batch)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Strings) != len(that1.Strings) {
		return false
	}
	for i := range this.Strings {
		if !bytes.Equal(this.Strings[i], that1.Strings[i]) {
			return false
		}
	}
	if len(this.Events) != len(that1.Events) {
		return false
	}
	for i := range this.Events {
		if !this.Events[i].Equal(that1.Events[i]) {
			return false
		}
	}
	return true
}
func (this *Event) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Event)
	if !ok {
		that2, ok := that.(Event)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Value) != len(that1.Value) {
		return false
	}
	for i := range this.Value {
		if !this.Value[i].Equal(that1.Value[i]) {
			return false
		}
	}
	return true
}
func (this *Value) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Value)
	if !ok {
		that2, ok := that.(Value)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.Value == nil {
		if this.Value != nil {
			return false
		}
	} else if this.Value == nil {
		return false
	} else if !this.Value.Equal(that1.Value) {
		return false
	}
	return true
}
func (this *Value_Binary) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Value_Binary)
	if !ok {
		that2, ok := that.(Value_Binary)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Binary != that1.Binary {
		return false
	}
	return true
}
func (this *Value_String_) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Value_String_)
	if !ok {
		that2, ok := that.(Value_String_)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.String_ != that1.String_ {
		return false
	}
	return true
}
func (this *Value_Int) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Value_Int)
	if !ok {
		that2, ok := that.(Value_Int)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Int != that1.Int {
		return false
	}
	return true
}
func (this *Value_Uint) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Value_Uint)
	if !ok {
		that2, ok := that.(Value_Uint)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Uint != that1.Uint {
		return false
	}
	return true
}
func (this *Value_Double) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Value_Double)
	if !ok {
		that2, ok := that.(Value_Double)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Double != that1.Double {
		return false
	}
	return true
}
func (this *Value_Bool) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Value_Bool)
	if !ok {
		that2, ok := that.(Value_Bool)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Bool != that1.Bool {
		return false
	}
	return true
}
func (this *IngestRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*IngestRequest)
	if !ok {
		that2, ok := that.(IngestRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Batch.Equal(that1.Batch) {
		return false
	}
	return true
}
func (this *IngestResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*IngestResponse)
	if !ok {
		that2, ok := that.(IngestResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	return true
}
func (this *Batch) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&talaria.Batch{")
	keysForStrings := make([]uint32, 0, len(this.Strings))
	for k, _ := range this.Strings {
		keysForStrings = append(keysForStrings, k)
	}
	github_com_gogo_protobuf_sortkeys.Uint32s(keysForStrings)
	mapStringForStrings := "map[uint32][]byte{"
	for _, k := range keysForStrings {
		mapStringForStrings += fmt.Sprintf("%#v: %#v,", k, this.Strings[k])
	}
	mapStringForStrings += "}"
	if this.Strings != nil {
		s = append(s, "Strings: "+mapStringForStrings+",\n")
	}
	if this.Events != nil {
		s = append(s, "Events: "+fmt.Sprintf("%#v", this.Events)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Event) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&talaria.Event{")
	keysForValue := make([]uint32, 0, len(this.Value))
	for k, _ := range this.Value {
		keysForValue = append(keysForValue, k)
	}
	github_com_gogo_protobuf_sortkeys.Uint32s(keysForValue)
	mapStringForValue := "map[uint32]*Value{"
	for _, k := range keysForValue {
		mapStringForValue += fmt.Sprintf("%#v: %#v,", k, this.Value[k])
	}
	mapStringForValue += "}"
	if this.Value != nil {
		s = append(s, "Value: "+mapStringForValue+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Value) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&talaria.Value{")
	if this.Value != nil {
		s = append(s, "Value: "+fmt.Sprintf("%#v", this.Value)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Value_Binary) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&talaria.Value_Binary{` +
		`Binary:` + fmt.Sprintf("%#v", this.Binary) + `}`}, ", ")
	return s
}
func (this *Value_String_) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&talaria.Value_String_{` +
		`String_:` + fmt.Sprintf("%#v", this.String_) + `}`}, ", ")
	return s
}
func (this *Value_Int) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&talaria.Value_Int{` +
		`Int:` + fmt.Sprintf("%#v", this.Int) + `}`}, ", ")
	return s
}
func (this *Value_Uint) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&talaria.Value_Uint{` +
		`Uint:` + fmt.Sprintf("%#v", this.Uint) + `}`}, ", ")
	return s
}
func (this *Value_Double) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&talaria.Value_Double{` +
		`Double:` + fmt.Sprintf("%#v", this.Double) + `}`}, ", ")
	return s
}
func (this *Value_Bool) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&talaria.Value_Bool{` +
		`Bool:` + fmt.Sprintf("%#v", this.Bool) + `}`}, ", ")
	return s
}
func (this *IngestRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&talaria.IngestRequest{")
	if this.Batch != nil {
		s = append(s, "Batch: "+fmt.Sprintf("%#v", this.Batch)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *IngestResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 4)
	s = append(s, "&talaria.IngestResponse{")
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringTalaria(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// IngressClient is the client API for Ingress service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type IngressClient interface {
	Ingest(ctx context.Context, in *IngestRequest, opts ...grpc.CallOption) (*IngestResponse, error)
}

type ingressClient struct {
	cc *grpc.ClientConn
}

func NewIngressClient(cc *grpc.ClientConn) IngressClient {
	return &ingressClient{cc}
}

func (c *ingressClient) Ingest(ctx context.Context, in *IngestRequest, opts ...grpc.CallOption) (*IngestResponse, error) {
	out := new(IngestResponse)
	err := c.cc.Invoke(ctx, "/talaria.Ingress/Ingest", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// IngressServer is the server API for Ingress service.
type IngressServer interface {
	Ingest(context.Context, *IngestRequest) (*IngestResponse, error)
}

// UnimplementedIngressServer can be embedded to have forward compatible implementations.
type UnimplementedIngressServer struct {
}

func (*UnimplementedIngressServer) Ingest(ctx context.Context, req *IngestRequest) (*IngestResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Ingest not implemented")
}

func RegisterIngressServer(s *grpc.Server, srv IngressServer) {
	s.RegisterService(&_Ingress_serviceDesc, srv)
}

func _Ingress_Ingest_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IngestRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IngressServer).Ingest(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/talaria.Ingress/Ingest",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IngressServer).Ingest(ctx, req.(*IngestRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Ingress_serviceDesc = grpc.ServiceDesc{
	ServiceName: "talaria.Ingress",
	HandlerType: (*IngressServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Ingest",
			Handler:    _Ingress_Ingest_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "talaria.proto",
}

func (m *Batch) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Batch) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Batch) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Events) > 0 {
		for iNdEx := len(m.Events) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Events[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTalaria(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Strings) > 0 {
		for k := range m.Strings {
			v := m.Strings[k]
			baseI := i
			if len(v) > 0 {
				i -= len(v)
				copy(dAtA[i:], v)
				i = encodeVarintTalaria(dAtA, i, uint64(len(v)))
				i--
				dAtA[i] = 0x12
			}
			i = encodeVarintTalaria(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintTalaria(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *Event) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Event) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Event) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Value) > 0 {
		for k := range m.Value {
			v := m.Value[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintTalaria(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i = encodeVarintTalaria(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintTalaria(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *Value) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Value) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Value) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Value != nil {
		{
			size := m.Value.Size()
			i -= size
			if _, err := m.Value.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *Value_Binary) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Value_Binary) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintTalaria(dAtA, i, uint64(m.Binary))
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}
func (m *Value_String_) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Value_String_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintTalaria(dAtA, i, uint64(m.String_))
	i--
	dAtA[i] = 0x10
	return len(dAtA) - i, nil
}
func (m *Value_Int) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Value_Int) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintTalaria(dAtA, i, uint64(m.Int))
	i--
	dAtA[i] = 0x18
	return len(dAtA) - i, nil
}
func (m *Value_Uint) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Value_Uint) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintTalaria(dAtA, i, uint64(m.Uint))
	i--
	dAtA[i] = 0x20
	return len(dAtA) - i, nil
}
func (m *Value_Double) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Value_Double) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= 8
	encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Double))))
	i--
	dAtA[i] = 0x29
	return len(dAtA) - i, nil
}
func (m *Value_Bool) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Value_Bool) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i--
	if m.Bool {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x30
	return len(dAtA) - i, nil
}
func (m *IngestRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IngestRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IngestRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Batch != nil {
		{
			size, err := m.Batch.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTalaria(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *IngestResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IngestResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IngestResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func encodeVarintTalaria(dAtA []byte, offset int, v uint64) int {
	offset -= sovTalaria(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Batch) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Strings) > 0 {
		for k, v := range m.Strings {
			_ = k
			_ = v
			l = 0
			if len(v) > 0 {
				l = 1 + len(v) + sovTalaria(uint64(len(v)))
			}
			mapEntrySize := 1 + sovTalaria(uint64(k)) + l
			n += mapEntrySize + 1 + sovTalaria(uint64(mapEntrySize))
		}
	}
	if len(m.Events) > 0 {
		for _, e := range m.Events {
			l = e.Size()
			n += 1 + l + sovTalaria(uint64(l))
		}
	}
	return n
}

func (m *Event) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Value) > 0 {
		for k, v := range m.Value {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovTalaria(uint64(l))
			}
			mapEntrySize := 1 + sovTalaria(uint64(k)) + l
			n += mapEntrySize + 1 + sovTalaria(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *Value) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Value != nil {
		n += m.Value.Size()
	}
	return n
}

func (m *Value_Binary) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovTalaria(uint64(m.Binary))
	return n
}
func (m *Value_String_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovTalaria(uint64(m.String_))
	return n
}
func (m *Value_Int) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovTalaria(uint64(m.Int))
	return n
}
func (m *Value_Uint) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovTalaria(uint64(m.Uint))
	return n
}
func (m *Value_Double) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 9
	return n
}
func (m *Value_Bool) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 2
	return n
}
func (m *IngestRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Batch != nil {
		l = m.Batch.Size()
		n += 1 + l + sovTalaria(uint64(l))
	}
	return n
}

func (m *IngestResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func sovTalaria(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTalaria(x uint64) (n int) {
	return sovTalaria(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *Batch) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForEvents := "[]*Event{"
	for _, f := range this.Events {
		repeatedStringForEvents += strings.Replace(f.String(), "Event", "Event", 1) + ","
	}
	repeatedStringForEvents += "}"
	keysForStrings := make([]uint32, 0, len(this.Strings))
	for k, _ := range this.Strings {
		keysForStrings = append(keysForStrings, k)
	}
	github_com_gogo_protobuf_sortkeys.Uint32s(keysForStrings)
	mapStringForStrings := "map[uint32][]byte{"
	for _, k := range keysForStrings {
		mapStringForStrings += fmt.Sprintf("%v: %v,", k, this.Strings[k])
	}
	mapStringForStrings += "}"
	s := strings.Join([]string{`&Batch{`,
		`Strings:` + mapStringForStrings + `,`,
		`Events:` + repeatedStringForEvents + `,`,
		`}`,
	}, "")
	return s
}
func (this *Event) String() string {
	if this == nil {
		return "nil"
	}
	keysForValue := make([]uint32, 0, len(this.Value))
	for k, _ := range this.Value {
		keysForValue = append(keysForValue, k)
	}
	github_com_gogo_protobuf_sortkeys.Uint32s(keysForValue)
	mapStringForValue := "map[uint32]*Value{"
	for _, k := range keysForValue {
		mapStringForValue += fmt.Sprintf("%v: %v,", k, this.Value[k])
	}
	mapStringForValue += "}"
	s := strings.Join([]string{`&Event{`,
		`Value:` + mapStringForValue + `,`,
		`}`,
	}, "")
	return s
}
func (this *Value) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Value{`,
		`Value:` + fmt.Sprintf("%v", this.Value) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Value_Binary) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Value_Binary{`,
		`Binary:` + fmt.Sprintf("%v", this.Binary) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Value_String_) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Value_String_{`,
		`String_:` + fmt.Sprintf("%v", this.String_) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Value_Int) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Value_Int{`,
		`Int:` + fmt.Sprintf("%v", this.Int) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Value_Uint) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Value_Uint{`,
		`Uint:` + fmt.Sprintf("%v", this.Uint) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Value_Double) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Value_Double{`,
		`Double:` + fmt.Sprintf("%v", this.Double) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Value_Bool) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Value_Bool{`,
		`Bool:` + fmt.Sprintf("%v", this.Bool) + `,`,
		`}`,
	}, "")
	return s
}
func (this *IngestRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&IngestRequest{`,
		`Batch:` + strings.Replace(this.Batch.String(), "Batch", "Batch", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *IngestResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&IngestResponse{`,
		`}`,
	}, "")
	return s
}
func valueToStringTalaria(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *Batch) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTalaria
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Batch: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Batch: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Strings", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTalaria
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTalaria
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTalaria
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Strings == nil {
				m.Strings = make(map[uint32][]byte)
			}
			var mapkey uint32
			mapvalue := []byte{}
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTalaria
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTalaria
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapbyteLen uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTalaria
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapbyteLen |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intMapbyteLen := int(mapbyteLen)
					if intMapbyteLen < 0 {
						return ErrInvalidLengthTalaria
					}
					postbytesIndex := iNdEx + intMapbyteLen
					if postbytesIndex < 0 {
						return ErrInvalidLengthTalaria
					}
					if postbytesIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = make([]byte, mapbyteLen)
					copy(mapvalue, dAtA[iNdEx:postbytesIndex])
					iNdEx = postbytesIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTalaria(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTalaria
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Strings[mapkey] = mapvalue
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Events", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTalaria
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTalaria
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTalaria
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Events = append(m.Events, &Event{})
			if err := m.Events[len(m.Events)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTalaria(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTalaria
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTalaria
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Event) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTalaria
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Event: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Event: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTalaria
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTalaria
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTalaria
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Value == nil {
				m.Value = make(map[uint32]*Value)
			}
			var mapkey uint32
			var mapvalue *Value
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTalaria
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTalaria
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTalaria
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthTalaria
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthTalaria
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &Value{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTalaria(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTalaria
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Value[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTalaria(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTalaria
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTalaria
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Value) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTalaria
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Value: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Value: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Binary", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTalaria
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Value = &Value_Binary{v}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field String_", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTalaria
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Value = &Value_String_{v}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Int", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTalaria
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Value = &Value_Int{v}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uint", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTalaria
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Value = &Value_Uint{v}
		case 5:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Double", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Value = &Value_Double{float64(math.Float64frombits(v))}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bool", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTalaria
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Value = &Value_Bool{b}
		default:
			iNdEx = preIndex
			skippy, err := skipTalaria(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTalaria
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTalaria
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IngestRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTalaria
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IngestRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IngestRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Batch", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTalaria
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTalaria
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTalaria
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Batch == nil {
				m.Batch = &Batch{}
			}
			if err := m.Batch.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTalaria(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTalaria
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTalaria
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IngestResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTalaria
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IngestResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IngestResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTalaria(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTalaria
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTalaria
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTalaria(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTalaria
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTalaria
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTalaria
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTalaria
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTalaria
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTalaria
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTalaria        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTalaria          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTalaria = fmt.Errorf("proto: unexpected end of group")
)
