// Code generated by protoc-gen-gogo.
// source: talaria.proto
// DO NOT EDIT!

/*
	Package talaria is a generated protocol buffer package.

	It is generated from these files:
		talaria.proto

	It has these top-level messages:
		IngestRequest
		IngestResponse
		Batch
		Event
		Value
		DescribeRequest
		DescribeResponse
		TableMeta
		ColumnMeta
		GetSplitsRequest
		GetSplitsResponse
		Endpoint
		Split
		GetRowsRequest
		GetRowsResponse
		Column
		ColumnOfInt32
		ColumnOfInt64
		ColumnOfFloat64
		ColumnOfBools
		ColumnOfString
*/
package talaria

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"

import bytes "bytes"

import strings "strings"
import reflect "reflect"
import github_com_gogo_protobuf_sortkeys "github.com/gogo/protobuf/sortkeys"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

// IngestRequest represents an ingestion request.
type IngestRequest struct {
	// Types that are valid to be assigned to Data:
	//	*IngestRequest_Batch
	//	*IngestRequest_Orc
	Data isIngestRequest_Data `protobuf_oneof:"data"`
}

func (m *IngestRequest) Reset()                    { *m = IngestRequest{} }
func (*IngestRequest) ProtoMessage()               {}
func (*IngestRequest) Descriptor() ([]byte, []int) { return fileDescriptorTalaria, []int{0} }

type isIngestRequest_Data interface {
	isIngestRequest_Data()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type IngestRequest_Batch struct {
	Batch *Batch `protobuf:"bytes,1,opt,name=batch,oneof"`
}
type IngestRequest_Orc struct {
	Orc []byte `protobuf:"bytes,2,opt,name=orc,proto3,oneof"`
}

func (*IngestRequest_Batch) isIngestRequest_Data() {}
func (*IngestRequest_Orc) isIngestRequest_Data()   {}

func (m *IngestRequest) GetData() isIngestRequest_Data {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *IngestRequest) GetBatch() *Batch {
	if x, ok := m.GetData().(*IngestRequest_Batch); ok {
		return x.Batch
	}
	return nil
}

func (m *IngestRequest) GetOrc() []byte {
	if x, ok := m.GetData().(*IngestRequest_Orc); ok {
		return x.Orc
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*IngestRequest) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _IngestRequest_OneofMarshaler, _IngestRequest_OneofUnmarshaler, _IngestRequest_OneofSizer, []interface{}{
		(*IngestRequest_Batch)(nil),
		(*IngestRequest_Orc)(nil),
	}
}

func _IngestRequest_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*IngestRequest)
	// data
	switch x := m.Data.(type) {
	case *IngestRequest_Batch:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Batch); err != nil {
			return err
		}
	case *IngestRequest_Orc:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		_ = b.EncodeRawBytes(x.Orc)
	case nil:
	default:
		return fmt.Errorf("IngestRequest.Data has unexpected type %T", x)
	}
	return nil
}

func _IngestRequest_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*IngestRequest)
	switch tag {
	case 1: // data.batch
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Batch)
		err := b.DecodeMessage(msg)
		m.Data = &IngestRequest_Batch{msg}
		return true, err
	case 2: // data.orc
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeRawBytes(true)
		m.Data = &IngestRequest_Orc{x}
		return true, err
	default:
		return false, nil
	}
}

func _IngestRequest_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*IngestRequest)
	// data
	switch x := m.Data.(type) {
	case *IngestRequest_Batch:
		s := proto.Size(x.Batch)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *IngestRequest_Orc:
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.Orc)))
		n += len(x.Orc)
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// IngestResponse represents an ingestion response.
type IngestResponse struct {
}

func (m *IngestResponse) Reset()                    { *m = IngestResponse{} }
func (*IngestResponse) ProtoMessage()               {}
func (*IngestResponse) Descriptor() ([]byte, []int) { return fileDescriptorTalaria, []int{1} }

// Batch represents an event batch. It contains a map of strings in order
// to minimize the size.
type Batch struct {
	Strings map[uint32][]byte `protobuf:"bytes,1,rep,name=strings" json:"strings,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	Events  []*Event          `protobuf:"bytes,2,rep,name=events" json:"events,omitempty"`
}

func (m *Batch) Reset()                    { *m = Batch{} }
func (*Batch) ProtoMessage()               {}
func (*Batch) Descriptor() ([]byte, []int) { return fileDescriptorTalaria, []int{2} }

func (m *Batch) GetStrings() map[uint32][]byte {
	if m != nil {
		return m.Strings
	}
	return nil
}

func (m *Batch) GetEvents() []*Event {
	if m != nil {
		return m.Events
	}
	return nil
}

// Event represents a single event. Name as well as value columns are
// interned strings which are present in a batch.
type Event struct {
	Value map[uint32]*Value `protobuf:"bytes,1,rep,name=value" json:"value,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *Event) Reset()                    { *m = Event{} }
func (*Event) ProtoMessage()               {}
func (*Event) Descriptor() ([]byte, []int) { return fileDescriptorTalaria, []int{3} }

func (m *Event) GetValue() map[uint32]*Value {
	if m != nil {
		return m.Value
	}
	return nil
}

// Value represents a value
type Value struct {
	// Types that are valid to be assigned to Value:
	//	*Value_Int32
	//	*Value_Int64
	//	*Value_Float64
	//	*Value_String_
	//	*Value_Bool
	//	*Value_Time
	//	*Value_Json
	Value isValue_Value `protobuf_oneof:"value"`
}

func (m *Value) Reset()                    { *m = Value{} }
func (*Value) ProtoMessage()               {}
func (*Value) Descriptor() ([]byte, []int) { return fileDescriptorTalaria, []int{4} }

type isValue_Value interface {
	isValue_Value()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type Value_Int32 struct {
	Int32 int32 `protobuf:"varint,1,opt,name=int32,proto3,oneof"`
}
type Value_Int64 struct {
	Int64 int64 `protobuf:"varint,2,opt,name=int64,proto3,oneof"`
}
type Value_Float64 struct {
	Float64 float64 `protobuf:"fixed64,3,opt,name=float64,proto3,oneof"`
}
type Value_String_ struct {
	String_ uint32 `protobuf:"varint,4,opt,name=string,proto3,oneof"`
}
type Value_Bool struct {
	Bool bool `protobuf:"varint,5,opt,name=bool,proto3,oneof"`
}
type Value_Time struct {
	Time int64 `protobuf:"varint,6,opt,name=time,proto3,oneof"`
}
type Value_Json struct {
	Json uint32 `protobuf:"varint,7,opt,name=json,proto3,oneof"`
}

func (*Value_Int32) isValue_Value()   {}
func (*Value_Int64) isValue_Value()   {}
func (*Value_Float64) isValue_Value() {}
func (*Value_String_) isValue_Value() {}
func (*Value_Bool) isValue_Value()    {}
func (*Value_Time) isValue_Value()    {}
func (*Value_Json) isValue_Value()    {}

func (m *Value) GetValue() isValue_Value {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *Value) GetInt32() int32 {
	if x, ok := m.GetValue().(*Value_Int32); ok {
		return x.Int32
	}
	return 0
}

func (m *Value) GetInt64() int64 {
	if x, ok := m.GetValue().(*Value_Int64); ok {
		return x.Int64
	}
	return 0
}

func (m *Value) GetFloat64() float64 {
	if x, ok := m.GetValue().(*Value_Float64); ok {
		return x.Float64
	}
	return 0
}

func (m *Value) GetString_() uint32 {
	if x, ok := m.GetValue().(*Value_String_); ok {
		return x.String_
	}
	return 0
}

func (m *Value) GetBool() bool {
	if x, ok := m.GetValue().(*Value_Bool); ok {
		return x.Bool
	}
	return false
}

func (m *Value) GetTime() int64 {
	if x, ok := m.GetValue().(*Value_Time); ok {
		return x.Time
	}
	return 0
}

func (m *Value) GetJson() uint32 {
	if x, ok := m.GetValue().(*Value_Json); ok {
		return x.Json
	}
	return 0
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Value) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _Value_OneofMarshaler, _Value_OneofUnmarshaler, _Value_OneofSizer, []interface{}{
		(*Value_Int32)(nil),
		(*Value_Int64)(nil),
		(*Value_Float64)(nil),
		(*Value_String_)(nil),
		(*Value_Bool)(nil),
		(*Value_Time)(nil),
		(*Value_Json)(nil),
	}
}

func _Value_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Value)
	// value
	switch x := m.Value.(type) {
	case *Value_Int32:
		_ = b.EncodeVarint(1<<3 | proto.WireVarint)
		_ = b.EncodeVarint(uint64(x.Int32))
	case *Value_Int64:
		_ = b.EncodeVarint(2<<3 | proto.WireVarint)
		_ = b.EncodeVarint(uint64(x.Int64))
	case *Value_Float64:
		_ = b.EncodeVarint(3<<3 | proto.WireFixed64)
		_ = b.EncodeFixed64(math.Float64bits(x.Float64))
	case *Value_String_:
		_ = b.EncodeVarint(4<<3 | proto.WireVarint)
		_ = b.EncodeVarint(uint64(x.String_))
	case *Value_Bool:
		t := uint64(0)
		if x.Bool {
			t = 1
		}
		_ = b.EncodeVarint(5<<3 | proto.WireVarint)
		_ = b.EncodeVarint(t)
	case *Value_Time:
		_ = b.EncodeVarint(6<<3 | proto.WireVarint)
		_ = b.EncodeVarint(uint64(x.Time))
	case *Value_Json:
		_ = b.EncodeVarint(7<<3 | proto.WireVarint)
		_ = b.EncodeVarint(uint64(x.Json))
	case nil:
	default:
		return fmt.Errorf("Value.Value has unexpected type %T", x)
	}
	return nil
}

func _Value_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Value)
	switch tag {
	case 1: // value.int32
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Value = &Value_Int32{int32(x)}
		return true, err
	case 2: // value.int64
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Value = &Value_Int64{int64(x)}
		return true, err
	case 3: // value.float64
		if wire != proto.WireFixed64 {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeFixed64()
		m.Value = &Value_Float64{math.Float64frombits(x)}
		return true, err
	case 4: // value.string
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Value = &Value_String_{uint32(x)}
		return true, err
	case 5: // value.bool
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Value = &Value_Bool{x != 0}
		return true, err
	case 6: // value.time
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Value = &Value_Time{int64(x)}
		return true, err
	case 7: // value.json
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Value = &Value_Json{uint32(x)}
		return true, err
	default:
		return false, nil
	}
}

func _Value_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*Value)
	// value
	switch x := m.Value.(type) {
	case *Value_Int32:
		n += proto.SizeVarint(1<<3 | proto.WireVarint)
		n += proto.SizeVarint(uint64(x.Int32))
	case *Value_Int64:
		n += proto.SizeVarint(2<<3 | proto.WireVarint)
		n += proto.SizeVarint(uint64(x.Int64))
	case *Value_Float64:
		n += proto.SizeVarint(3<<3 | proto.WireFixed64)
		n += 8
	case *Value_String_:
		n += proto.SizeVarint(4<<3 | proto.WireVarint)
		n += proto.SizeVarint(uint64(x.String_))
	case *Value_Bool:
		n += proto.SizeVarint(5<<3 | proto.WireVarint)
		n += 1
	case *Value_Time:
		n += proto.SizeVarint(6<<3 | proto.WireVarint)
		n += proto.SizeVarint(uint64(x.Time))
	case *Value_Json:
		n += proto.SizeVarint(7<<3 | proto.WireVarint)
		n += proto.SizeVarint(uint64(x.Json))
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// DescribeRequest represents an request to list the tables and schemas.
type DescribeRequest struct {
}

func (m *DescribeRequest) Reset()                    { *m = DescribeRequest{} }
func (*DescribeRequest) ProtoMessage()               {}
func (*DescribeRequest) Descriptor() ([]byte, []int) { return fileDescriptorTalaria, []int{5} }

// DescribeResponse represents an response that returns tables and their schemas.
type DescribeResponse struct {
	Tables []*TableMeta `protobuf:"bytes,1,rep,name=tables" json:"tables,omitempty"`
}

func (m *DescribeResponse) Reset()                    { *m = DescribeResponse{} }
func (*DescribeResponse) ProtoMessage()               {}
func (*DescribeResponse) Descriptor() ([]byte, []int) { return fileDescriptorTalaria, []int{6} }

func (m *DescribeResponse) GetTables() []*TableMeta {
	if m != nil {
		return m.Tables
	}
	return nil
}

// TableMeta represents table metadata
type TableMeta struct {
	Schema  string        `protobuf:"bytes,1,opt,name=schema,proto3" json:"schema,omitempty"`
	Table   string        `protobuf:"bytes,2,opt,name=table,proto3" json:"table,omitempty"`
	Columns []*ColumnMeta `protobuf:"bytes,3,rep,name=columns" json:"columns,omitempty"`
}

func (m *TableMeta) Reset()                    { *m = TableMeta{} }
func (*TableMeta) ProtoMessage()               {}
func (*TableMeta) Descriptor() ([]byte, []int) { return fileDescriptorTalaria, []int{7} }

func (m *TableMeta) GetSchema() string {
	if m != nil {
		return m.Schema
	}
	return ""
}

func (m *TableMeta) GetTable() string {
	if m != nil {
		return m.Table
	}
	return ""
}

func (m *TableMeta) GetColumns() []*ColumnMeta {
	if m != nil {
		return m.Columns
	}
	return nil
}

// ColumnMeta represents a column metadata
type ColumnMeta struct {
	Name    string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Type    string `protobuf:"bytes,2,opt,name=type,proto3" json:"type,omitempty"`
	Comment string `protobuf:"bytes,3,opt,name=comment,proto3" json:"comment,omitempty"`
}

func (m *ColumnMeta) Reset()                    { *m = ColumnMeta{} }
func (*ColumnMeta) ProtoMessage()               {}
func (*ColumnMeta) Descriptor() ([]byte, []int) { return fileDescriptorTalaria, []int{8} }

func (m *ColumnMeta) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ColumnMeta) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *ColumnMeta) GetComment() string {
	if m != nil {
		return m.Comment
	}
	return ""
}

// GetSplitsRequest represents an request to get the splits for a table.
type GetSplitsRequest struct {
	Schema    string   `protobuf:"bytes,1,opt,name=schema,proto3" json:"schema,omitempty"`
	Table     string   `protobuf:"bytes,2,opt,name=table,proto3" json:"table,omitempty"`
	Columns   []string `protobuf:"bytes,3,rep,name=columns" json:"columns,omitempty"`
	Filters   []string `protobuf:"bytes,4,rep,name=filters" json:"filters,omitempty"`
	MaxSplits int32    `protobuf:"varint,5,opt,name=maxSplits,proto3" json:"maxSplits,omitempty"`
	NextToken []byte   `protobuf:"bytes,6,opt,name=nextToken,proto3" json:"nextToken,omitempty"`
}

func (m *GetSplitsRequest) Reset()                    { *m = GetSplitsRequest{} }
func (*GetSplitsRequest) ProtoMessage()               {}
func (*GetSplitsRequest) Descriptor() ([]byte, []int) { return fileDescriptorTalaria, []int{9} }

func (m *GetSplitsRequest) GetSchema() string {
	if m != nil {
		return m.Schema
	}
	return ""
}

func (m *GetSplitsRequest) GetTable() string {
	if m != nil {
		return m.Table
	}
	return ""
}

func (m *GetSplitsRequest) GetColumns() []string {
	if m != nil {
		return m.Columns
	}
	return nil
}

func (m *GetSplitsRequest) GetFilters() []string {
	if m != nil {
		return m.Filters
	}
	return nil
}

func (m *GetSplitsRequest) GetMaxSplits() int32 {
	if m != nil {
		return m.MaxSplits
	}
	return 0
}

func (m *GetSplitsRequest) GetNextToken() []byte {
	if m != nil {
		return m.NextToken
	}
	return nil
}

// GetSplitsResponse represents an response containing the splits for a table.
type GetSplitsResponse struct {
	Splits    []*Split `protobuf:"bytes,1,rep,name=splits" json:"splits,omitempty"`
	NextToken []byte   `protobuf:"bytes,2,opt,name=nextToken,proto3" json:"nextToken,omitempty"`
}

func (m *GetSplitsResponse) Reset()                    { *m = GetSplitsResponse{} }
func (*GetSplitsResponse) ProtoMessage()               {}
func (*GetSplitsResponse) Descriptor() ([]byte, []int) { return fileDescriptorTalaria, []int{10} }

func (m *GetSplitsResponse) GetSplits() []*Split {
	if m != nil {
		return m.Splits
	}
	return nil
}

func (m *GetSplitsResponse) GetNextToken() []byte {
	if m != nil {
		return m.NextToken
	}
	return nil
}

// Endpoint represents a host/port combination
type Endpoint struct {
	Host string `protobuf:"bytes,1,opt,name=host,proto3" json:"host,omitempty"`
	Port int32  `protobuf:"varint,2,opt,name=port,proto3" json:"port,omitempty"`
}

func (m *Endpoint) Reset()                    { *m = Endpoint{} }
func (*Endpoint) ProtoMessage()               {}
func (*Endpoint) Descriptor() ([]byte, []int) { return fileDescriptorTalaria, []int{11} }

func (m *Endpoint) GetHost() string {
	if m != nil {
		return m.Host
	}
	return ""
}

func (m *Endpoint) GetPort() int32 {
	if m != nil {
		return m.Port
	}
	return 0
}

// Split represents the split information
type Split struct {
	SplitID []byte      `protobuf:"bytes,1,opt,name=splitID,proto3" json:"splitID,omitempty"`
	Hosts   []*Endpoint `protobuf:"bytes,2,rep,name=hosts" json:"hosts,omitempty"`
}

func (m *Split) Reset()                    { *m = Split{} }
func (*Split) ProtoMessage()               {}
func (*Split) Descriptor() ([]byte, []int) { return fileDescriptorTalaria, []int{12} }

func (m *Split) GetSplitID() []byte {
	if m != nil {
		return m.SplitID
	}
	return nil
}

func (m *Split) GetHosts() []*Endpoint {
	if m != nil {
		return m.Hosts
	}
	return nil
}

// GetRowsRequest represents an request to get the rows for a split.
type GetRowsRequest struct {
	SplitID   []byte   `protobuf:"bytes,1,opt,name=splitID,proto3" json:"splitID,omitempty"`
	Columns   []string `protobuf:"bytes,2,rep,name=columns" json:"columns,omitempty"`
	MaxBytes  int64    `protobuf:"varint,3,opt,name=maxBytes,proto3" json:"maxBytes,omitempty"`
	NextToken []byte   `protobuf:"bytes,4,opt,name=nextToken,proto3" json:"nextToken,omitempty"`
}

func (m *GetRowsRequest) Reset()                    { *m = GetRowsRequest{} }
func (*GetRowsRequest) ProtoMessage()               {}
func (*GetRowsRequest) Descriptor() ([]byte, []int) { return fileDescriptorTalaria, []int{13} }

func (m *GetRowsRequest) GetSplitID() []byte {
	if m != nil {
		return m.SplitID
	}
	return nil
}

func (m *GetRowsRequest) GetColumns() []string {
	if m != nil {
		return m.Columns
	}
	return nil
}

func (m *GetRowsRequest) GetMaxBytes() int64 {
	if m != nil {
		return m.MaxBytes
	}
	return 0
}

func (m *GetRowsRequest) GetNextToken() []byte {
	if m != nil {
		return m.NextToken
	}
	return nil
}

// GetRowsResponse represents a response that returns the rows.
type GetRowsResponse struct {
	Columns   []*Column `protobuf:"bytes,1,rep,name=columns" json:"columns,omitempty"`
	RowCount  int32     `protobuf:"varint,2,opt,name=rowCount,proto3" json:"rowCount,omitempty"`
	NextToken []byte    `protobuf:"bytes,3,opt,name=nextToken,proto3" json:"nextToken,omitempty"`
}

func (m *GetRowsResponse) Reset()                    { *m = GetRowsResponse{} }
func (*GetRowsResponse) ProtoMessage()               {}
func (*GetRowsResponse) Descriptor() ([]byte, []int) { return fileDescriptorTalaria, []int{14} }

func (m *GetRowsResponse) GetColumns() []*Column {
	if m != nil {
		return m.Columns
	}
	return nil
}

func (m *GetRowsResponse) GetRowCount() int32 {
	if m != nil {
		return m.RowCount
	}
	return 0
}

func (m *GetRowsResponse) GetNextToken() []byte {
	if m != nil {
		return m.NextToken
	}
	return nil
}

// Column represents a column.
type Column struct {
	// Types that are valid to be assigned to Value:
	//	*Column_Int32
	//	*Column_Int64
	//	*Column_Float64
	//	*Column_String_
	//	*Column_Bool
	//	*Column_Time
	//	*Column_Json
	Value isColumn_Value `protobuf_oneof:"value"`
}

func (m *Column) Reset()                    { *m = Column{} }
func (*Column) ProtoMessage()               {}
func (*Column) Descriptor() ([]byte, []int) { return fileDescriptorTalaria, []int{15} }

type isColumn_Value interface {
	isColumn_Value()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type Column_Int32 struct {
	Int32 *ColumnOfInt32 `protobuf:"bytes,1,opt,name=int32,oneof"`
}
type Column_Int64 struct {
	Int64 *ColumnOfInt64 `protobuf:"bytes,2,opt,name=int64,oneof"`
}
type Column_Float64 struct {
	Float64 *ColumnOfFloat64 `protobuf:"bytes,3,opt,name=float64,oneof"`
}
type Column_String_ struct {
	String_ *ColumnOfString `protobuf:"bytes,4,opt,name=string,oneof"`
}
type Column_Bool struct {
	Bool *ColumnOfBools `protobuf:"bytes,5,opt,name=bool,oneof"`
}
type Column_Time struct {
	Time *ColumnOfInt64 `protobuf:"bytes,6,opt,name=time,oneof"`
}
type Column_Json struct {
	Json *ColumnOfString `protobuf:"bytes,7,opt,name=json,oneof"`
}

func (*Column_Int32) isColumn_Value()   {}
func (*Column_Int64) isColumn_Value()   {}
func (*Column_Float64) isColumn_Value() {}
func (*Column_String_) isColumn_Value() {}
func (*Column_Bool) isColumn_Value()    {}
func (*Column_Time) isColumn_Value()    {}
func (*Column_Json) isColumn_Value()    {}

func (m *Column) GetValue() isColumn_Value {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *Column) GetInt32() *ColumnOfInt32 {
	if x, ok := m.GetValue().(*Column_Int32); ok {
		return x.Int32
	}
	return nil
}

func (m *Column) GetInt64() *ColumnOfInt64 {
	if x, ok := m.GetValue().(*Column_Int64); ok {
		return x.Int64
	}
	return nil
}

func (m *Column) GetFloat64() *ColumnOfFloat64 {
	if x, ok := m.GetValue().(*Column_Float64); ok {
		return x.Float64
	}
	return nil
}

func (m *Column) GetString_() *ColumnOfString {
	if x, ok := m.GetValue().(*Column_String_); ok {
		return x.String_
	}
	return nil
}

func (m *Column) GetBool() *ColumnOfBools {
	if x, ok := m.GetValue().(*Column_Bool); ok {
		return x.Bool
	}
	return nil
}

func (m *Column) GetTime() *ColumnOfInt64 {
	if x, ok := m.GetValue().(*Column_Time); ok {
		return x.Time
	}
	return nil
}

func (m *Column) GetJson() *ColumnOfString {
	if x, ok := m.GetValue().(*Column_Json); ok {
		return x.Json
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Column) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _Column_OneofMarshaler, _Column_OneofUnmarshaler, _Column_OneofSizer, []interface{}{
		(*Column_Int32)(nil),
		(*Column_Int64)(nil),
		(*Column_Float64)(nil),
		(*Column_String_)(nil),
		(*Column_Bool)(nil),
		(*Column_Time)(nil),
		(*Column_Json)(nil),
	}
}

func _Column_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Column)
	// value
	switch x := m.Value.(type) {
	case *Column_Int32:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Int32); err != nil {
			return err
		}
	case *Column_Int64:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Int64); err != nil {
			return err
		}
	case *Column_Float64:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Float64); err != nil {
			return err
		}
	case *Column_String_:
		_ = b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.String_); err != nil {
			return err
		}
	case *Column_Bool:
		_ = b.EncodeVarint(5<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Bool); err != nil {
			return err
		}
	case *Column_Time:
		_ = b.EncodeVarint(6<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Time); err != nil {
			return err
		}
	case *Column_Json:
		_ = b.EncodeVarint(7<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Json); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("Column.Value has unexpected type %T", x)
	}
	return nil
}

func _Column_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Column)
	switch tag {
	case 1: // value.int32
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ColumnOfInt32)
		err := b.DecodeMessage(msg)
		m.Value = &Column_Int32{msg}
		return true, err
	case 2: // value.int64
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ColumnOfInt64)
		err := b.DecodeMessage(msg)
		m.Value = &Column_Int64{msg}
		return true, err
	case 3: // value.float64
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ColumnOfFloat64)
		err := b.DecodeMessage(msg)
		m.Value = &Column_Float64{msg}
		return true, err
	case 4: // value.string
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ColumnOfString)
		err := b.DecodeMessage(msg)
		m.Value = &Column_String_{msg}
		return true, err
	case 5: // value.bool
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ColumnOfBools)
		err := b.DecodeMessage(msg)
		m.Value = &Column_Bool{msg}
		return true, err
	case 6: // value.time
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ColumnOfInt64)
		err := b.DecodeMessage(msg)
		m.Value = &Column_Time{msg}
		return true, err
	case 7: // value.json
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ColumnOfString)
		err := b.DecodeMessage(msg)
		m.Value = &Column_Json{msg}
		return true, err
	default:
		return false, nil
	}
}

func _Column_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*Column)
	// value
	switch x := m.Value.(type) {
	case *Column_Int32:
		s := proto.Size(x.Int32)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Column_Int64:
		s := proto.Size(x.Int64)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Column_Float64:
		s := proto.Size(x.Float64)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Column_String_:
		s := proto.Size(x.String_)
		n += proto.SizeVarint(4<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Column_Bool:
		s := proto.Size(x.Bool)
		n += proto.SizeVarint(5<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Column_Time:
		s := proto.Size(x.Time)
		n += proto.SizeVarint(6<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Column_Json:
		s := proto.Size(x.Json)
		n += proto.SizeVarint(7<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Column containing Int32 values
type ColumnOfInt32 struct {
	Nulls []bool  `protobuf:"varint,1,rep,packed,name=nulls" json:"nulls,omitempty"`
	Ints  []int32 `protobuf:"varint,2,rep,packed,name=ints" json:"ints,omitempty"`
}

func (m *ColumnOfInt32) Reset()                    { *m = ColumnOfInt32{} }
func (*ColumnOfInt32) ProtoMessage()               {}
func (*ColumnOfInt32) Descriptor() ([]byte, []int) { return fileDescriptorTalaria, []int{16} }

func (m *ColumnOfInt32) GetNulls() []bool {
	if m != nil {
		return m.Nulls
	}
	return nil
}

func (m *ColumnOfInt32) GetInts() []int32 {
	if m != nil {
		return m.Ints
	}
	return nil
}

// Column containing Int64 values
type ColumnOfInt64 struct {
	Nulls []bool  `protobuf:"varint,1,rep,packed,name=nulls" json:"nulls,omitempty"`
	Longs []int64 `protobuf:"varint,2,rep,packed,name=longs" json:"longs,omitempty"`
}

func (m *ColumnOfInt64) Reset()                    { *m = ColumnOfInt64{} }
func (*ColumnOfInt64) ProtoMessage()               {}
func (*ColumnOfInt64) Descriptor() ([]byte, []int) { return fileDescriptorTalaria, []int{17} }

func (m *ColumnOfInt64) GetNulls() []bool {
	if m != nil {
		return m.Nulls
	}
	return nil
}

func (m *ColumnOfInt64) GetLongs() []int64 {
	if m != nil {
		return m.Longs
	}
	return nil
}

// Column containing Float64 values
type ColumnOfFloat64 struct {
	Nulls   []bool    `protobuf:"varint,1,rep,packed,name=nulls" json:"nulls,omitempty"`
	Doubles []float64 `protobuf:"fixed64,2,rep,packed,name=doubles" json:"doubles,omitempty"`
}

func (m *ColumnOfFloat64) Reset()                    { *m = ColumnOfFloat64{} }
func (*ColumnOfFloat64) ProtoMessage()               {}
func (*ColumnOfFloat64) Descriptor() ([]byte, []int) { return fileDescriptorTalaria, []int{18} }

func (m *ColumnOfFloat64) GetNulls() []bool {
	if m != nil {
		return m.Nulls
	}
	return nil
}

func (m *ColumnOfFloat64) GetDoubles() []float64 {
	if m != nil {
		return m.Doubles
	}
	return nil
}

// Column containing Boolean values
type ColumnOfBools struct {
	Nulls []bool `protobuf:"varint,1,rep,packed,name=nulls" json:"nulls,omitempty"`
	Bools []bool `protobuf:"varint,2,rep,packed,name=bools" json:"bools,omitempty"`
}

func (m *ColumnOfBools) Reset()                    { *m = ColumnOfBools{} }
func (*ColumnOfBools) ProtoMessage()               {}
func (*ColumnOfBools) Descriptor() ([]byte, []int) { return fileDescriptorTalaria, []int{19} }

func (m *ColumnOfBools) GetNulls() []bool {
	if m != nil {
		return m.Nulls
	}
	return nil
}

func (m *ColumnOfBools) GetBools() []bool {
	if m != nil {
		return m.Bools
	}
	return nil
}

// Column containing String values
type ColumnOfString struct {
	Nulls []bool  `protobuf:"varint,1,rep,packed,name=nulls" json:"nulls,omitempty"`
	Sizes []int32 `protobuf:"varint,2,rep,packed,name=sizes" json:"sizes,omitempty"`
	Bytes []byte  `protobuf:"bytes,3,opt,name=bytes,proto3" json:"bytes,omitempty"`
}

func (m *ColumnOfString) Reset()                    { *m = ColumnOfString{} }
func (*ColumnOfString) ProtoMessage()               {}
func (*ColumnOfString) Descriptor() ([]byte, []int) { return fileDescriptorTalaria, []int{20} }

func (m *ColumnOfString) GetNulls() []bool {
	if m != nil {
		return m.Nulls
	}
	return nil
}

func (m *ColumnOfString) GetSizes() []int32 {
	if m != nil {
		return m.Sizes
	}
	return nil
}

func (m *ColumnOfString) GetBytes() []byte {
	if m != nil {
		return m.Bytes
	}
	return nil
}

func init() {
	proto.RegisterType((*IngestRequest)(nil), "talaria.IngestRequest")
	proto.RegisterType((*IngestResponse)(nil), "talaria.IngestResponse")
	proto.RegisterType((*Batch)(nil), "talaria.Batch")
	proto.RegisterType((*Event)(nil), "talaria.Event")
	proto.RegisterType((*Value)(nil), "talaria.Value")
	proto.RegisterType((*DescribeRequest)(nil), "talaria.DescribeRequest")
	proto.RegisterType((*DescribeResponse)(nil), "talaria.DescribeResponse")
	proto.RegisterType((*TableMeta)(nil), "talaria.TableMeta")
	proto.RegisterType((*ColumnMeta)(nil), "talaria.ColumnMeta")
	proto.RegisterType((*GetSplitsRequest)(nil), "talaria.GetSplitsRequest")
	proto.RegisterType((*GetSplitsResponse)(nil), "talaria.GetSplitsResponse")
	proto.RegisterType((*Endpoint)(nil), "talaria.Endpoint")
	proto.RegisterType((*Split)(nil), "talaria.Split")
	proto.RegisterType((*GetRowsRequest)(nil), "talaria.GetRowsRequest")
	proto.RegisterType((*GetRowsResponse)(nil), "talaria.GetRowsResponse")
	proto.RegisterType((*Column)(nil), "talaria.Column")
	proto.RegisterType((*ColumnOfInt32)(nil), "talaria.ColumnOfInt32")
	proto.RegisterType((*ColumnOfInt64)(nil), "talaria.ColumnOfInt64")
	proto.RegisterType((*ColumnOfFloat64)(nil), "talaria.ColumnOfFloat64")
	proto.RegisterType((*ColumnOfBools)(nil), "talaria.ColumnOfBools")
	proto.RegisterType((*ColumnOfString)(nil), "talaria.ColumnOfString")
}
func (this *IngestRequest) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*IngestRequest)
	if !ok {
		that2, ok := that.(IngestRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if that1.Data == nil {
		if this.Data != nil {
			return false
		}
	} else if this.Data == nil {
		return false
	} else if !this.Data.Equal(that1.Data) {
		return false
	}
	return true
}
func (this *IngestRequest_Batch) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*IngestRequest_Batch)
	if !ok {
		that2, ok := that.(IngestRequest_Batch)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.Batch.Equal(that1.Batch) {
		return false
	}
	return true
}
func (this *IngestRequest_Orc) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*IngestRequest_Orc)
	if !ok {
		that2, ok := that.(IngestRequest_Orc)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !bytes.Equal(this.Orc, that1.Orc) {
		return false
	}
	return true
}
func (this *IngestResponse) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*IngestResponse)
	if !ok {
		that2, ok := that.(IngestResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	return true
}
func (this *Batch) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Batch)
	if !ok {
		that2, ok := that.(Batch)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if len(this.Strings) != len(that1.Strings) {
		return false
	}
	for i := range this.Strings {
		if !bytes.Equal(this.Strings[i], that1.Strings[i]) {
			return false
		}
	}
	if len(this.Events) != len(that1.Events) {
		return false
	}
	for i := range this.Events {
		if !this.Events[i].Equal(that1.Events[i]) {
			return false
		}
	}
	return true
}
func (this *Event) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Event)
	if !ok {
		that2, ok := that.(Event)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if len(this.Value) != len(that1.Value) {
		return false
	}
	for i := range this.Value {
		if !this.Value[i].Equal(that1.Value[i]) {
			return false
		}
	}
	return true
}
func (this *Value) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Value)
	if !ok {
		that2, ok := that.(Value)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if that1.Value == nil {
		if this.Value != nil {
			return false
		}
	} else if this.Value == nil {
		return false
	} else if !this.Value.Equal(that1.Value) {
		return false
	}
	return true
}
func (this *Value_Int32) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Value_Int32)
	if !ok {
		that2, ok := that.(Value_Int32)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Int32 != that1.Int32 {
		return false
	}
	return true
}
func (this *Value_Int64) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Value_Int64)
	if !ok {
		that2, ok := that.(Value_Int64)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Int64 != that1.Int64 {
		return false
	}
	return true
}
func (this *Value_Float64) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Value_Float64)
	if !ok {
		that2, ok := that.(Value_Float64)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Float64 != that1.Float64 {
		return false
	}
	return true
}
func (this *Value_String_) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Value_String_)
	if !ok {
		that2, ok := that.(Value_String_)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.String_ != that1.String_ {
		return false
	}
	return true
}
func (this *Value_Bool) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Value_Bool)
	if !ok {
		that2, ok := that.(Value_Bool)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Bool != that1.Bool {
		return false
	}
	return true
}
func (this *Value_Time) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Value_Time)
	if !ok {
		that2, ok := that.(Value_Time)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Time != that1.Time {
		return false
	}
	return true
}
func (this *Value_Json) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Value_Json)
	if !ok {
		that2, ok := that.(Value_Json)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Json != that1.Json {
		return false
	}
	return true
}
func (this *DescribeRequest) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*DescribeRequest)
	if !ok {
		that2, ok := that.(DescribeRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	return true
}
func (this *DescribeResponse) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*DescribeResponse)
	if !ok {
		that2, ok := that.(DescribeResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if len(this.Tables) != len(that1.Tables) {
		return false
	}
	for i := range this.Tables {
		if !this.Tables[i].Equal(that1.Tables[i]) {
			return false
		}
	}
	return true
}
func (this *TableMeta) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*TableMeta)
	if !ok {
		that2, ok := that.(TableMeta)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Schema != that1.Schema {
		return false
	}
	if this.Table != that1.Table {
		return false
	}
	if len(this.Columns) != len(that1.Columns) {
		return false
	}
	for i := range this.Columns {
		if !this.Columns[i].Equal(that1.Columns[i]) {
			return false
		}
	}
	return true
}
func (this *ColumnMeta) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*ColumnMeta)
	if !ok {
		that2, ok := that.(ColumnMeta)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.Type != that1.Type {
		return false
	}
	if this.Comment != that1.Comment {
		return false
	}
	return true
}
func (this *GetSplitsRequest) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*GetSplitsRequest)
	if !ok {
		that2, ok := that.(GetSplitsRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Schema != that1.Schema {
		return false
	}
	if this.Table != that1.Table {
		return false
	}
	if len(this.Columns) != len(that1.Columns) {
		return false
	}
	for i := range this.Columns {
		if this.Columns[i] != that1.Columns[i] {
			return false
		}
	}
	if len(this.Filters) != len(that1.Filters) {
		return false
	}
	for i := range this.Filters {
		if this.Filters[i] != that1.Filters[i] {
			return false
		}
	}
	if this.MaxSplits != that1.MaxSplits {
		return false
	}
	if !bytes.Equal(this.NextToken, that1.NextToken) {
		return false
	}
	return true
}
func (this *GetSplitsResponse) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*GetSplitsResponse)
	if !ok {
		that2, ok := that.(GetSplitsResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if len(this.Splits) != len(that1.Splits) {
		return false
	}
	for i := range this.Splits {
		if !this.Splits[i].Equal(that1.Splits[i]) {
			return false
		}
	}
	if !bytes.Equal(this.NextToken, that1.NextToken) {
		return false
	}
	return true
}
func (this *Endpoint) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Endpoint)
	if !ok {
		that2, ok := that.(Endpoint)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Host != that1.Host {
		return false
	}
	if this.Port != that1.Port {
		return false
	}
	return true
}
func (this *Split) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Split)
	if !ok {
		that2, ok := that.(Split)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !bytes.Equal(this.SplitID, that1.SplitID) {
		return false
	}
	if len(this.Hosts) != len(that1.Hosts) {
		return false
	}
	for i := range this.Hosts {
		if !this.Hosts[i].Equal(that1.Hosts[i]) {
			return false
		}
	}
	return true
}
func (this *GetRowsRequest) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*GetRowsRequest)
	if !ok {
		that2, ok := that.(GetRowsRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !bytes.Equal(this.SplitID, that1.SplitID) {
		return false
	}
	if len(this.Columns) != len(that1.Columns) {
		return false
	}
	for i := range this.Columns {
		if this.Columns[i] != that1.Columns[i] {
			return false
		}
	}
	if this.MaxBytes != that1.MaxBytes {
		return false
	}
	if !bytes.Equal(this.NextToken, that1.NextToken) {
		return false
	}
	return true
}
func (this *GetRowsResponse) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*GetRowsResponse)
	if !ok {
		that2, ok := that.(GetRowsResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if len(this.Columns) != len(that1.Columns) {
		return false
	}
	for i := range this.Columns {
		if !this.Columns[i].Equal(that1.Columns[i]) {
			return false
		}
	}
	if this.RowCount != that1.RowCount {
		return false
	}
	if !bytes.Equal(this.NextToken, that1.NextToken) {
		return false
	}
	return true
}
func (this *Column) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Column)
	if !ok {
		that2, ok := that.(Column)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if that1.Value == nil {
		if this.Value != nil {
			return false
		}
	} else if this.Value == nil {
		return false
	} else if !this.Value.Equal(that1.Value) {
		return false
	}
	return true
}
func (this *Column_Int32) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Column_Int32)
	if !ok {
		that2, ok := that.(Column_Int32)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.Int32.Equal(that1.Int32) {
		return false
	}
	return true
}
func (this *Column_Int64) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Column_Int64)
	if !ok {
		that2, ok := that.(Column_Int64)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.Int64.Equal(that1.Int64) {
		return false
	}
	return true
}
func (this *Column_Float64) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Column_Float64)
	if !ok {
		that2, ok := that.(Column_Float64)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.Float64.Equal(that1.Float64) {
		return false
	}
	return true
}
func (this *Column_String_) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Column_String_)
	if !ok {
		that2, ok := that.(Column_String_)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.String_.Equal(that1.String_) {
		return false
	}
	return true
}
func (this *Column_Bool) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Column_Bool)
	if !ok {
		that2, ok := that.(Column_Bool)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.Bool.Equal(that1.Bool) {
		return false
	}
	return true
}
func (this *Column_Time) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Column_Time)
	if !ok {
		that2, ok := that.(Column_Time)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.Time.Equal(that1.Time) {
		return false
	}
	return true
}
func (this *Column_Json) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Column_Json)
	if !ok {
		that2, ok := that.(Column_Json)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.Json.Equal(that1.Json) {
		return false
	}
	return true
}
func (this *ColumnOfInt32) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*ColumnOfInt32)
	if !ok {
		that2, ok := that.(ColumnOfInt32)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if len(this.Nulls) != len(that1.Nulls) {
		return false
	}
	for i := range this.Nulls {
		if this.Nulls[i] != that1.Nulls[i] {
			return false
		}
	}
	if len(this.Ints) != len(that1.Ints) {
		return false
	}
	for i := range this.Ints {
		if this.Ints[i] != that1.Ints[i] {
			return false
		}
	}
	return true
}
func (this *ColumnOfInt64) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*ColumnOfInt64)
	if !ok {
		that2, ok := that.(ColumnOfInt64)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if len(this.Nulls) != len(that1.Nulls) {
		return false
	}
	for i := range this.Nulls {
		if this.Nulls[i] != that1.Nulls[i] {
			return false
		}
	}
	if len(this.Longs) != len(that1.Longs) {
		return false
	}
	for i := range this.Longs {
		if this.Longs[i] != that1.Longs[i] {
			return false
		}
	}
	return true
}
func (this *ColumnOfFloat64) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*ColumnOfFloat64)
	if !ok {
		that2, ok := that.(ColumnOfFloat64)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if len(this.Nulls) != len(that1.Nulls) {
		return false
	}
	for i := range this.Nulls {
		if this.Nulls[i] != that1.Nulls[i] {
			return false
		}
	}
	if len(this.Doubles) != len(that1.Doubles) {
		return false
	}
	for i := range this.Doubles {
		if this.Doubles[i] != that1.Doubles[i] {
			return false
		}
	}
	return true
}
func (this *ColumnOfBools) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*ColumnOfBools)
	if !ok {
		that2, ok := that.(ColumnOfBools)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if len(this.Nulls) != len(that1.Nulls) {
		return false
	}
	for i := range this.Nulls {
		if this.Nulls[i] != that1.Nulls[i] {
			return false
		}
	}
	if len(this.Bools) != len(that1.Bools) {
		return false
	}
	for i := range this.Bools {
		if this.Bools[i] != that1.Bools[i] {
			return false
		}
	}
	return true
}
func (this *ColumnOfString) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*ColumnOfString)
	if !ok {
		that2, ok := that.(ColumnOfString)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if len(this.Nulls) != len(that1.Nulls) {
		return false
	}
	for i := range this.Nulls {
		if this.Nulls[i] != that1.Nulls[i] {
			return false
		}
	}
	if len(this.Sizes) != len(that1.Sizes) {
		return false
	}
	for i := range this.Sizes {
		if this.Sizes[i] != that1.Sizes[i] {
			return false
		}
	}
	if !bytes.Equal(this.Bytes, that1.Bytes) {
		return false
	}
	return true
}
func (this *IngestRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&talaria.IngestRequest{")
	if this.Data != nil {
		s = append(s, "Data: "+fmt.Sprintf("%#v", this.Data)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *IngestRequest_Batch) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&talaria.IngestRequest_Batch{` +
		`Batch:` + fmt.Sprintf("%#v", this.Batch) + `}`}, ", ")
	return s
}
func (this *IngestRequest_Orc) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&talaria.IngestRequest_Orc{` +
		`Orc:` + fmt.Sprintf("%#v", this.Orc) + `}`}, ", ")
	return s
}
func (this *IngestResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 4)
	s = append(s, "&talaria.IngestResponse{")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Batch) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&talaria.Batch{")
	keysForStrings := make([]uint32, 0, len(this.Strings))
	for k, _ := range this.Strings {
		keysForStrings = append(keysForStrings, k)
	}
	github_com_gogo_protobuf_sortkeys.Uint32s(keysForStrings)
	mapStringForStrings := "map[uint32][]byte{"
	for _, k := range keysForStrings {
		mapStringForStrings += fmt.Sprintf("%#v: %#v,", k, this.Strings[k])
	}
	mapStringForStrings += "}"
	if this.Strings != nil {
		s = append(s, "Strings: "+mapStringForStrings+",\n")
	}
	if this.Events != nil {
		s = append(s, "Events: "+fmt.Sprintf("%#v", this.Events)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Event) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&talaria.Event{")
	keysForValue := make([]uint32, 0, len(this.Value))
	for k, _ := range this.Value {
		keysForValue = append(keysForValue, k)
	}
	github_com_gogo_protobuf_sortkeys.Uint32s(keysForValue)
	mapStringForValue := "map[uint32]*Value{"
	for _, k := range keysForValue {
		mapStringForValue += fmt.Sprintf("%#v: %#v,", k, this.Value[k])
	}
	mapStringForValue += "}"
	if this.Value != nil {
		s = append(s, "Value: "+mapStringForValue+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Value) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 11)
	s = append(s, "&talaria.Value{")
	if this.Value != nil {
		s = append(s, "Value: "+fmt.Sprintf("%#v", this.Value)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Value_Int32) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&talaria.Value_Int32{` +
		`Int32:` + fmt.Sprintf("%#v", this.Int32) + `}`}, ", ")
	return s
}
func (this *Value_Int64) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&talaria.Value_Int64{` +
		`Int64:` + fmt.Sprintf("%#v", this.Int64) + `}`}, ", ")
	return s
}
func (this *Value_Float64) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&talaria.Value_Float64{` +
		`Float64:` + fmt.Sprintf("%#v", this.Float64) + `}`}, ", ")
	return s
}
func (this *Value_String_) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&talaria.Value_String_{` +
		`String_:` + fmt.Sprintf("%#v", this.String_) + `}`}, ", ")
	return s
}
func (this *Value_Bool) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&talaria.Value_Bool{` +
		`Bool:` + fmt.Sprintf("%#v", this.Bool) + `}`}, ", ")
	return s
}
func (this *Value_Time) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&talaria.Value_Time{` +
		`Time:` + fmt.Sprintf("%#v", this.Time) + `}`}, ", ")
	return s
}
func (this *Value_Json) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&talaria.Value_Json{` +
		`Json:` + fmt.Sprintf("%#v", this.Json) + `}`}, ", ")
	return s
}
func (this *DescribeRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 4)
	s = append(s, "&talaria.DescribeRequest{")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DescribeResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&talaria.DescribeResponse{")
	if this.Tables != nil {
		s = append(s, "Tables: "+fmt.Sprintf("%#v", this.Tables)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TableMeta) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&talaria.TableMeta{")
	s = append(s, "Schema: "+fmt.Sprintf("%#v", this.Schema)+",\n")
	s = append(s, "Table: "+fmt.Sprintf("%#v", this.Table)+",\n")
	if this.Columns != nil {
		s = append(s, "Columns: "+fmt.Sprintf("%#v", this.Columns)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ColumnMeta) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&talaria.ColumnMeta{")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "Type: "+fmt.Sprintf("%#v", this.Type)+",\n")
	s = append(s, "Comment: "+fmt.Sprintf("%#v", this.Comment)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GetSplitsRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&talaria.GetSplitsRequest{")
	s = append(s, "Schema: "+fmt.Sprintf("%#v", this.Schema)+",\n")
	s = append(s, "Table: "+fmt.Sprintf("%#v", this.Table)+",\n")
	s = append(s, "Columns: "+fmt.Sprintf("%#v", this.Columns)+",\n")
	s = append(s, "Filters: "+fmt.Sprintf("%#v", this.Filters)+",\n")
	s = append(s, "MaxSplits: "+fmt.Sprintf("%#v", this.MaxSplits)+",\n")
	s = append(s, "NextToken: "+fmt.Sprintf("%#v", this.NextToken)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GetSplitsResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&talaria.GetSplitsResponse{")
	if this.Splits != nil {
		s = append(s, "Splits: "+fmt.Sprintf("%#v", this.Splits)+",\n")
	}
	s = append(s, "NextToken: "+fmt.Sprintf("%#v", this.NextToken)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Endpoint) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&talaria.Endpoint{")
	s = append(s, "Host: "+fmt.Sprintf("%#v", this.Host)+",\n")
	s = append(s, "Port: "+fmt.Sprintf("%#v", this.Port)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Split) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&talaria.Split{")
	s = append(s, "SplitID: "+fmt.Sprintf("%#v", this.SplitID)+",\n")
	if this.Hosts != nil {
		s = append(s, "Hosts: "+fmt.Sprintf("%#v", this.Hosts)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GetRowsRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&talaria.GetRowsRequest{")
	s = append(s, "SplitID: "+fmt.Sprintf("%#v", this.SplitID)+",\n")
	s = append(s, "Columns: "+fmt.Sprintf("%#v", this.Columns)+",\n")
	s = append(s, "MaxBytes: "+fmt.Sprintf("%#v", this.MaxBytes)+",\n")
	s = append(s, "NextToken: "+fmt.Sprintf("%#v", this.NextToken)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GetRowsResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&talaria.GetRowsResponse{")
	if this.Columns != nil {
		s = append(s, "Columns: "+fmt.Sprintf("%#v", this.Columns)+",\n")
	}
	s = append(s, "RowCount: "+fmt.Sprintf("%#v", this.RowCount)+",\n")
	s = append(s, "NextToken: "+fmt.Sprintf("%#v", this.NextToken)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Column) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 11)
	s = append(s, "&talaria.Column{")
	if this.Value != nil {
		s = append(s, "Value: "+fmt.Sprintf("%#v", this.Value)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Column_Int32) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&talaria.Column_Int32{` +
		`Int32:` + fmt.Sprintf("%#v", this.Int32) + `}`}, ", ")
	return s
}
func (this *Column_Int64) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&talaria.Column_Int64{` +
		`Int64:` + fmt.Sprintf("%#v", this.Int64) + `}`}, ", ")
	return s
}
func (this *Column_Float64) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&talaria.Column_Float64{` +
		`Float64:` + fmt.Sprintf("%#v", this.Float64) + `}`}, ", ")
	return s
}
func (this *Column_String_) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&talaria.Column_String_{` +
		`String_:` + fmt.Sprintf("%#v", this.String_) + `}`}, ", ")
	return s
}
func (this *Column_Bool) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&talaria.Column_Bool{` +
		`Bool:` + fmt.Sprintf("%#v", this.Bool) + `}`}, ", ")
	return s
}
func (this *Column_Time) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&talaria.Column_Time{` +
		`Time:` + fmt.Sprintf("%#v", this.Time) + `}`}, ", ")
	return s
}
func (this *Column_Json) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&talaria.Column_Json{` +
		`Json:` + fmt.Sprintf("%#v", this.Json) + `}`}, ", ")
	return s
}
func (this *ColumnOfInt32) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&talaria.ColumnOfInt32{")
	s = append(s, "Nulls: "+fmt.Sprintf("%#v", this.Nulls)+",\n")
	s = append(s, "Ints: "+fmt.Sprintf("%#v", this.Ints)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ColumnOfInt64) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&talaria.ColumnOfInt64{")
	s = append(s, "Nulls: "+fmt.Sprintf("%#v", this.Nulls)+",\n")
	s = append(s, "Longs: "+fmt.Sprintf("%#v", this.Longs)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ColumnOfFloat64) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&talaria.ColumnOfFloat64{")
	s = append(s, "Nulls: "+fmt.Sprintf("%#v", this.Nulls)+",\n")
	s = append(s, "Doubles: "+fmt.Sprintf("%#v", this.Doubles)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ColumnOfBools) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&talaria.ColumnOfBools{")
	s = append(s, "Nulls: "+fmt.Sprintf("%#v", this.Nulls)+",\n")
	s = append(s, "Bools: "+fmt.Sprintf("%#v", this.Bools)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ColumnOfString) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&talaria.ColumnOfString{")
	s = append(s, "Nulls: "+fmt.Sprintf("%#v", this.Nulls)+",\n")
	s = append(s, "Sizes: "+fmt.Sprintf("%#v", this.Sizes)+",\n")
	s = append(s, "Bytes: "+fmt.Sprintf("%#v", this.Bytes)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringTalaria(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for Ingress service

type IngressClient interface {
	Ingest(ctx context.Context, in *IngestRequest, opts ...grpc.CallOption) (*IngestResponse, error)
}

type ingressClient struct {
	cc *grpc.ClientConn
}

func NewIngressClient(cc *grpc.ClientConn) IngressClient {
	return &ingressClient{cc}
}

func (c *ingressClient) Ingest(ctx context.Context, in *IngestRequest, opts ...grpc.CallOption) (*IngestResponse, error) {
	out := new(IngestResponse)
	err := grpc.Invoke(ctx, "/talaria.Ingress/Ingest", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Ingress service

type IngressServer interface {
	Ingest(context.Context, *IngestRequest) (*IngestResponse, error)
}

func RegisterIngressServer(s *grpc.Server, srv IngressServer) {
	s.RegisterService(&_Ingress_serviceDesc, srv)
}

func _Ingress_Ingest_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IngestRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IngressServer).Ingest(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/talaria.Ingress/Ingest",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IngressServer).Ingest(ctx, req.(*IngestRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Ingress_serviceDesc = grpc.ServiceDesc{
	ServiceName: "talaria.Ingress",
	HandlerType: (*IngressServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Ingest",
			Handler:    _Ingress_Ingest_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "talaria.proto",
}

// Client API for Query service

type QueryClient interface {
	// Describe returns the list of schema/table combinations and the metadata
	Describe(ctx context.Context, in *DescribeRequest, opts ...grpc.CallOption) (*DescribeResponse, error)
	// GetSplits returns the list of splits for a particular table/filter combination
	GetSplits(ctx context.Context, in *GetSplitsRequest, opts ...grpc.CallOption) (*GetSplitsResponse, error)
	// GetRows returns the rows for a particular split
	GetRows(ctx context.Context, in *GetRowsRequest, opts ...grpc.CallOption) (*GetRowsResponse, error)
}

type queryClient struct {
	cc *grpc.ClientConn
}

func NewQueryClient(cc *grpc.ClientConn) QueryClient {
	return &queryClient{cc}
}

func (c *queryClient) Describe(ctx context.Context, in *DescribeRequest, opts ...grpc.CallOption) (*DescribeResponse, error) {
	out := new(DescribeResponse)
	err := grpc.Invoke(ctx, "/talaria.Query/Describe", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) GetSplits(ctx context.Context, in *GetSplitsRequest, opts ...grpc.CallOption) (*GetSplitsResponse, error) {
	out := new(GetSplitsResponse)
	err := grpc.Invoke(ctx, "/talaria.Query/GetSplits", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) GetRows(ctx context.Context, in *GetRowsRequest, opts ...grpc.CallOption) (*GetRowsResponse, error) {
	out := new(GetRowsResponse)
	err := grpc.Invoke(ctx, "/talaria.Query/GetRows", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Query service

type QueryServer interface {
	// Describe returns the list of schema/table combinations and the metadata
	Describe(context.Context, *DescribeRequest) (*DescribeResponse, error)
	// GetSplits returns the list of splits for a particular table/filter combination
	GetSplits(context.Context, *GetSplitsRequest) (*GetSplitsResponse, error)
	// GetRows returns the rows for a particular split
	GetRows(context.Context, *GetRowsRequest) (*GetRowsResponse, error)
}

func RegisterQueryServer(s *grpc.Server, srv QueryServer) {
	s.RegisterService(&_Query_serviceDesc, srv)
}

func _Query_Describe_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DescribeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).Describe(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/talaria.Query/Describe",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).Describe(ctx, req.(*DescribeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_GetSplits_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetSplitsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).GetSplits(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/talaria.Query/GetSplits",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).GetSplits(ctx, req.(*GetSplitsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_GetRows_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetRowsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).GetRows(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/talaria.Query/GetRows",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).GetRows(ctx, req.(*GetRowsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Query_serviceDesc = grpc.ServiceDesc{
	ServiceName: "talaria.Query",
	HandlerType: (*QueryServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Describe",
			Handler:    _Query_Describe_Handler,
		},
		{
			MethodName: "GetSplits",
			Handler:    _Query_GetSplits_Handler,
		},
		{
			MethodName: "GetRows",
			Handler:    _Query_GetRows_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "talaria.proto",
}

func (m *IngestRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IngestRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Data != nil {
		nn1, err := m.Data.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn1
	}
	return i, nil
}

func (m *IngestRequest_Batch) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Batch != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTalaria(dAtA, i, uint64(m.Batch.Size()))
		n2, err := m.Batch.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	return i, nil
}
func (m *IngestRequest_Orc) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Orc != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTalaria(dAtA, i, uint64(len(m.Orc)))
		i += copy(dAtA[i:], m.Orc)
	}
	return i, nil
}
func (m *IngestResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IngestResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *Batch) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Batch) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Strings) > 0 {
		for k, _ := range m.Strings {
			dAtA[i] = 0xa
			i++
			v := m.Strings[k]
			byteSize := 0
			if len(v) > 0 {
				byteSize = 1 + len(v) + sovTalaria(uint64(len(v)))
			}
			mapSize := 1 + sovTalaria(uint64(k)) + byteSize
			i = encodeVarintTalaria(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintTalaria(dAtA, i, uint64(k))
			if len(v) > 0 {
				dAtA[i] = 0x12
				i++
				i = encodeVarintTalaria(dAtA, i, uint64(len(v)))
				i += copy(dAtA[i:], v)
			}
		}
	}
	if len(m.Events) > 0 {
		for _, msg := range m.Events {
			dAtA[i] = 0x12
			i++
			i = encodeVarintTalaria(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *Event) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Event) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Value) > 0 {
		for k, _ := range m.Value {
			dAtA[i] = 0xa
			i++
			v := m.Value[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovTalaria(uint64(msgSize))
			}
			mapSize := 1 + sovTalaria(uint64(k)) + msgSize
			i = encodeVarintTalaria(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintTalaria(dAtA, i, uint64(k))
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintTalaria(dAtA, i, uint64(v.Size()))
				n3, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n3
			}
		}
	}
	return i, nil
}

func (m *Value) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Value) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Value != nil {
		nn4, err := m.Value.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn4
	}
	return i, nil
}

func (m *Value_Int32) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x8
	i++
	i = encodeVarintTalaria(dAtA, i, uint64(m.Int32))
	return i, nil
}
func (m *Value_Int64) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x10
	i++
	i = encodeVarintTalaria(dAtA, i, uint64(m.Int64))
	return i, nil
}
func (m *Value_Float64) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x19
	i++
	i = encodeFixed64Talaria(dAtA, i, uint64(math.Float64bits(float64(m.Float64))))
	return i, nil
}
func (m *Value_String_) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x20
	i++
	i = encodeVarintTalaria(dAtA, i, uint64(m.String_))
	return i, nil
}
func (m *Value_Bool) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x28
	i++
	if m.Bool {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	return i, nil
}
func (m *Value_Time) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x30
	i++
	i = encodeVarintTalaria(dAtA, i, uint64(m.Time))
	return i, nil
}
func (m *Value_Json) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x38
	i++
	i = encodeVarintTalaria(dAtA, i, uint64(m.Json))
	return i, nil
}
func (m *DescribeRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DescribeRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *DescribeResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DescribeResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Tables) > 0 {
		for _, msg := range m.Tables {
			dAtA[i] = 0xa
			i++
			i = encodeVarintTalaria(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *TableMeta) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TableMeta) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Schema) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTalaria(dAtA, i, uint64(len(m.Schema)))
		i += copy(dAtA[i:], m.Schema)
	}
	if len(m.Table) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTalaria(dAtA, i, uint64(len(m.Table)))
		i += copy(dAtA[i:], m.Table)
	}
	if len(m.Columns) > 0 {
		for _, msg := range m.Columns {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintTalaria(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *ColumnMeta) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ColumnMeta) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTalaria(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Type) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTalaria(dAtA, i, uint64(len(m.Type)))
		i += copy(dAtA[i:], m.Type)
	}
	if len(m.Comment) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTalaria(dAtA, i, uint64(len(m.Comment)))
		i += copy(dAtA[i:], m.Comment)
	}
	return i, nil
}

func (m *GetSplitsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetSplitsRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Schema) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTalaria(dAtA, i, uint64(len(m.Schema)))
		i += copy(dAtA[i:], m.Schema)
	}
	if len(m.Table) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTalaria(dAtA, i, uint64(len(m.Table)))
		i += copy(dAtA[i:], m.Table)
	}
	if len(m.Columns) > 0 {
		for _, s := range m.Columns {
			dAtA[i] = 0x1a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Filters) > 0 {
		for _, s := range m.Filters {
			dAtA[i] = 0x22
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.MaxSplits != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintTalaria(dAtA, i, uint64(m.MaxSplits))
	}
	if len(m.NextToken) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintTalaria(dAtA, i, uint64(len(m.NextToken)))
		i += copy(dAtA[i:], m.NextToken)
	}
	return i, nil
}

func (m *GetSplitsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetSplitsResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Splits) > 0 {
		for _, msg := range m.Splits {
			dAtA[i] = 0xa
			i++
			i = encodeVarintTalaria(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.NextToken) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTalaria(dAtA, i, uint64(len(m.NextToken)))
		i += copy(dAtA[i:], m.NextToken)
	}
	return i, nil
}

func (m *Endpoint) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Endpoint) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Host) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTalaria(dAtA, i, uint64(len(m.Host)))
		i += copy(dAtA[i:], m.Host)
	}
	if m.Port != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintTalaria(dAtA, i, uint64(m.Port))
	}
	return i, nil
}

func (m *Split) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Split) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.SplitID) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTalaria(dAtA, i, uint64(len(m.SplitID)))
		i += copy(dAtA[i:], m.SplitID)
	}
	if len(m.Hosts) > 0 {
		for _, msg := range m.Hosts {
			dAtA[i] = 0x12
			i++
			i = encodeVarintTalaria(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *GetRowsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetRowsRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.SplitID) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTalaria(dAtA, i, uint64(len(m.SplitID)))
		i += copy(dAtA[i:], m.SplitID)
	}
	if len(m.Columns) > 0 {
		for _, s := range m.Columns {
			dAtA[i] = 0x12
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.MaxBytes != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintTalaria(dAtA, i, uint64(m.MaxBytes))
	}
	if len(m.NextToken) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTalaria(dAtA, i, uint64(len(m.NextToken)))
		i += copy(dAtA[i:], m.NextToken)
	}
	return i, nil
}

func (m *GetRowsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetRowsResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Columns) > 0 {
		for _, msg := range m.Columns {
			dAtA[i] = 0xa
			i++
			i = encodeVarintTalaria(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.RowCount != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintTalaria(dAtA, i, uint64(m.RowCount))
	}
	if len(m.NextToken) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTalaria(dAtA, i, uint64(len(m.NextToken)))
		i += copy(dAtA[i:], m.NextToken)
	}
	return i, nil
}

func (m *Column) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Column) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Value != nil {
		nn5, err := m.Value.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn5
	}
	return i, nil
}

func (m *Column_Int32) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Int32 != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTalaria(dAtA, i, uint64(m.Int32.Size()))
		n6, err := m.Int32.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	return i, nil
}
func (m *Column_Int64) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Int64 != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTalaria(dAtA, i, uint64(m.Int64.Size()))
		n7, err := m.Int64.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	return i, nil
}
func (m *Column_Float64) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Float64 != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTalaria(dAtA, i, uint64(m.Float64.Size()))
		n8, err := m.Float64.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	return i, nil
}
func (m *Column_String_) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.String_ != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTalaria(dAtA, i, uint64(m.String_.Size()))
		n9, err := m.String_.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	return i, nil
}
func (m *Column_Bool) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Bool != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintTalaria(dAtA, i, uint64(m.Bool.Size()))
		n10, err := m.Bool.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	return i, nil
}
func (m *Column_Time) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Time != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintTalaria(dAtA, i, uint64(m.Time.Size()))
		n11, err := m.Time.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	return i, nil
}
func (m *Column_Json) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Json != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintTalaria(dAtA, i, uint64(m.Json.Size()))
		n12, err := m.Json.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	return i, nil
}
func (m *ColumnOfInt32) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ColumnOfInt32) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Nulls) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTalaria(dAtA, i, uint64(len(m.Nulls)))
		for _, b := range m.Nulls {
			if b {
				dAtA[i] = 1
			} else {
				dAtA[i] = 0
			}
			i++
		}
	}
	if len(m.Ints) > 0 {
		dAtA14 := make([]byte, len(m.Ints)*10)
		var j13 int
		for _, num1 := range m.Ints {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA14[j13] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j13++
			}
			dAtA14[j13] = uint8(num)
			j13++
		}
		dAtA[i] = 0x12
		i++
		i = encodeVarintTalaria(dAtA, i, uint64(j13))
		i += copy(dAtA[i:], dAtA14[:j13])
	}
	return i, nil
}

func (m *ColumnOfInt64) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ColumnOfInt64) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Nulls) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTalaria(dAtA, i, uint64(len(m.Nulls)))
		for _, b := range m.Nulls {
			if b {
				dAtA[i] = 1
			} else {
				dAtA[i] = 0
			}
			i++
		}
	}
	if len(m.Longs) > 0 {
		dAtA16 := make([]byte, len(m.Longs)*10)
		var j15 int
		for _, num1 := range m.Longs {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA16[j15] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j15++
			}
			dAtA16[j15] = uint8(num)
			j15++
		}
		dAtA[i] = 0x12
		i++
		i = encodeVarintTalaria(dAtA, i, uint64(j15))
		i += copy(dAtA[i:], dAtA16[:j15])
	}
	return i, nil
}

func (m *ColumnOfFloat64) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ColumnOfFloat64) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Nulls) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTalaria(dAtA, i, uint64(len(m.Nulls)))
		for _, b := range m.Nulls {
			if b {
				dAtA[i] = 1
			} else {
				dAtA[i] = 0
			}
			i++
		}
	}
	if len(m.Doubles) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTalaria(dAtA, i, uint64(len(m.Doubles)*8))
		for _, num := range m.Doubles {
			f17 := math.Float64bits(float64(num))
			dAtA[i] = uint8(f17)
			i++
			dAtA[i] = uint8(f17 >> 8)
			i++
			dAtA[i] = uint8(f17 >> 16)
			i++
			dAtA[i] = uint8(f17 >> 24)
			i++
			dAtA[i] = uint8(f17 >> 32)
			i++
			dAtA[i] = uint8(f17 >> 40)
			i++
			dAtA[i] = uint8(f17 >> 48)
			i++
			dAtA[i] = uint8(f17 >> 56)
			i++
		}
	}
	return i, nil
}

func (m *ColumnOfBools) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ColumnOfBools) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Nulls) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTalaria(dAtA, i, uint64(len(m.Nulls)))
		for _, b := range m.Nulls {
			if b {
				dAtA[i] = 1
			} else {
				dAtA[i] = 0
			}
			i++
		}
	}
	if len(m.Bools) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTalaria(dAtA, i, uint64(len(m.Bools)))
		for _, b := range m.Bools {
			if b {
				dAtA[i] = 1
			} else {
				dAtA[i] = 0
			}
			i++
		}
	}
	return i, nil
}

func (m *ColumnOfString) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ColumnOfString) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Nulls) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTalaria(dAtA, i, uint64(len(m.Nulls)))
		for _, b := range m.Nulls {
			if b {
				dAtA[i] = 1
			} else {
				dAtA[i] = 0
			}
			i++
		}
	}
	if len(m.Sizes) > 0 {
		dAtA19 := make([]byte, len(m.Sizes)*10)
		var j18 int
		for _, num1 := range m.Sizes {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA19[j18] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j18++
			}
			dAtA19[j18] = uint8(num)
			j18++
		}
		dAtA[i] = 0x12
		i++
		i = encodeVarintTalaria(dAtA, i, uint64(j18))
		i += copy(dAtA[i:], dAtA19[:j18])
	}
	if len(m.Bytes) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTalaria(dAtA, i, uint64(len(m.Bytes)))
		i += copy(dAtA[i:], m.Bytes)
	}
	return i, nil
}

func encodeFixed64Talaria(dAtA []byte, offset int, v uint64) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	dAtA[offset+4] = uint8(v >> 32)
	dAtA[offset+5] = uint8(v >> 40)
	dAtA[offset+6] = uint8(v >> 48)
	dAtA[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32Talaria(dAtA []byte, offset int, v uint32) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintTalaria(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *IngestRequest) Size() (n int) {
	var l int
	_ = l
	if m.Data != nil {
		n += m.Data.Size()
	}
	return n
}

func (m *IngestRequest_Batch) Size() (n int) {
	var l int
	_ = l
	if m.Batch != nil {
		l = m.Batch.Size()
		n += 1 + l + sovTalaria(uint64(l))
	}
	return n
}
func (m *IngestRequest_Orc) Size() (n int) {
	var l int
	_ = l
	if m.Orc != nil {
		l = len(m.Orc)
		n += 1 + l + sovTalaria(uint64(l))
	}
	return n
}
func (m *IngestResponse) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *Batch) Size() (n int) {
	var l int
	_ = l
	if len(m.Strings) > 0 {
		for k, v := range m.Strings {
			_ = k
			_ = v
			l = 0
			if len(v) > 0 {
				l = 1 + len(v) + sovTalaria(uint64(len(v)))
			}
			mapEntrySize := 1 + sovTalaria(uint64(k)) + l
			n += mapEntrySize + 1 + sovTalaria(uint64(mapEntrySize))
		}
	}
	if len(m.Events) > 0 {
		for _, e := range m.Events {
			l = e.Size()
			n += 1 + l + sovTalaria(uint64(l))
		}
	}
	return n
}

func (m *Event) Size() (n int) {
	var l int
	_ = l
	if len(m.Value) > 0 {
		for k, v := range m.Value {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovTalaria(uint64(l))
			}
			mapEntrySize := 1 + sovTalaria(uint64(k)) + l
			n += mapEntrySize + 1 + sovTalaria(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *Value) Size() (n int) {
	var l int
	_ = l
	if m.Value != nil {
		n += m.Value.Size()
	}
	return n
}

func (m *Value_Int32) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovTalaria(uint64(m.Int32))
	return n
}
func (m *Value_Int64) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovTalaria(uint64(m.Int64))
	return n
}
func (m *Value_Float64) Size() (n int) {
	var l int
	_ = l
	n += 9
	return n
}
func (m *Value_String_) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovTalaria(uint64(m.String_))
	return n
}
func (m *Value_Bool) Size() (n int) {
	var l int
	_ = l
	n += 2
	return n
}
func (m *Value_Time) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovTalaria(uint64(m.Time))
	return n
}
func (m *Value_Json) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovTalaria(uint64(m.Json))
	return n
}
func (m *DescribeRequest) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *DescribeResponse) Size() (n int) {
	var l int
	_ = l
	if len(m.Tables) > 0 {
		for _, e := range m.Tables {
			l = e.Size()
			n += 1 + l + sovTalaria(uint64(l))
		}
	}
	return n
}

func (m *TableMeta) Size() (n int) {
	var l int
	_ = l
	l = len(m.Schema)
	if l > 0 {
		n += 1 + l + sovTalaria(uint64(l))
	}
	l = len(m.Table)
	if l > 0 {
		n += 1 + l + sovTalaria(uint64(l))
	}
	if len(m.Columns) > 0 {
		for _, e := range m.Columns {
			l = e.Size()
			n += 1 + l + sovTalaria(uint64(l))
		}
	}
	return n
}

func (m *ColumnMeta) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTalaria(uint64(l))
	}
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovTalaria(uint64(l))
	}
	l = len(m.Comment)
	if l > 0 {
		n += 1 + l + sovTalaria(uint64(l))
	}
	return n
}

func (m *GetSplitsRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.Schema)
	if l > 0 {
		n += 1 + l + sovTalaria(uint64(l))
	}
	l = len(m.Table)
	if l > 0 {
		n += 1 + l + sovTalaria(uint64(l))
	}
	if len(m.Columns) > 0 {
		for _, s := range m.Columns {
			l = len(s)
			n += 1 + l + sovTalaria(uint64(l))
		}
	}
	if len(m.Filters) > 0 {
		for _, s := range m.Filters {
			l = len(s)
			n += 1 + l + sovTalaria(uint64(l))
		}
	}
	if m.MaxSplits != 0 {
		n += 1 + sovTalaria(uint64(m.MaxSplits))
	}
	l = len(m.NextToken)
	if l > 0 {
		n += 1 + l + sovTalaria(uint64(l))
	}
	return n
}

func (m *GetSplitsResponse) Size() (n int) {
	var l int
	_ = l
	if len(m.Splits) > 0 {
		for _, e := range m.Splits {
			l = e.Size()
			n += 1 + l + sovTalaria(uint64(l))
		}
	}
	l = len(m.NextToken)
	if l > 0 {
		n += 1 + l + sovTalaria(uint64(l))
	}
	return n
}

func (m *Endpoint) Size() (n int) {
	var l int
	_ = l
	l = len(m.Host)
	if l > 0 {
		n += 1 + l + sovTalaria(uint64(l))
	}
	if m.Port != 0 {
		n += 1 + sovTalaria(uint64(m.Port))
	}
	return n
}

func (m *Split) Size() (n int) {
	var l int
	_ = l
	l = len(m.SplitID)
	if l > 0 {
		n += 1 + l + sovTalaria(uint64(l))
	}
	if len(m.Hosts) > 0 {
		for _, e := range m.Hosts {
			l = e.Size()
			n += 1 + l + sovTalaria(uint64(l))
		}
	}
	return n
}

func (m *GetRowsRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.SplitID)
	if l > 0 {
		n += 1 + l + sovTalaria(uint64(l))
	}
	if len(m.Columns) > 0 {
		for _, s := range m.Columns {
			l = len(s)
			n += 1 + l + sovTalaria(uint64(l))
		}
	}
	if m.MaxBytes != 0 {
		n += 1 + sovTalaria(uint64(m.MaxBytes))
	}
	l = len(m.NextToken)
	if l > 0 {
		n += 1 + l + sovTalaria(uint64(l))
	}
	return n
}

func (m *GetRowsResponse) Size() (n int) {
	var l int
	_ = l
	if len(m.Columns) > 0 {
		for _, e := range m.Columns {
			l = e.Size()
			n += 1 + l + sovTalaria(uint64(l))
		}
	}
	if m.RowCount != 0 {
		n += 1 + sovTalaria(uint64(m.RowCount))
	}
	l = len(m.NextToken)
	if l > 0 {
		n += 1 + l + sovTalaria(uint64(l))
	}
	return n
}

func (m *Column) Size() (n int) {
	var l int
	_ = l
	if m.Value != nil {
		n += m.Value.Size()
	}
	return n
}

func (m *Column_Int32) Size() (n int) {
	var l int
	_ = l
	if m.Int32 != nil {
		l = m.Int32.Size()
		n += 1 + l + sovTalaria(uint64(l))
	}
	return n
}
func (m *Column_Int64) Size() (n int) {
	var l int
	_ = l
	if m.Int64 != nil {
		l = m.Int64.Size()
		n += 1 + l + sovTalaria(uint64(l))
	}
	return n
}
func (m *Column_Float64) Size() (n int) {
	var l int
	_ = l
	if m.Float64 != nil {
		l = m.Float64.Size()
		n += 1 + l + sovTalaria(uint64(l))
	}
	return n
}
func (m *Column_String_) Size() (n int) {
	var l int
	_ = l
	if m.String_ != nil {
		l = m.String_.Size()
		n += 1 + l + sovTalaria(uint64(l))
	}
	return n
}
func (m *Column_Bool) Size() (n int) {
	var l int
	_ = l
	if m.Bool != nil {
		l = m.Bool.Size()
		n += 1 + l + sovTalaria(uint64(l))
	}
	return n
}
func (m *Column_Time) Size() (n int) {
	var l int
	_ = l
	if m.Time != nil {
		l = m.Time.Size()
		n += 1 + l + sovTalaria(uint64(l))
	}
	return n
}
func (m *Column_Json) Size() (n int) {
	var l int
	_ = l
	if m.Json != nil {
		l = m.Json.Size()
		n += 1 + l + sovTalaria(uint64(l))
	}
	return n
}
func (m *ColumnOfInt32) Size() (n int) {
	var l int
	_ = l
	if len(m.Nulls) > 0 {
		n += 1 + sovTalaria(uint64(len(m.Nulls))) + len(m.Nulls)*1
	}
	if len(m.Ints) > 0 {
		l = 0
		for _, e := range m.Ints {
			l += sovTalaria(uint64(e))
		}
		n += 1 + sovTalaria(uint64(l)) + l
	}
	return n
}

func (m *ColumnOfInt64) Size() (n int) {
	var l int
	_ = l
	if len(m.Nulls) > 0 {
		n += 1 + sovTalaria(uint64(len(m.Nulls))) + len(m.Nulls)*1
	}
	if len(m.Longs) > 0 {
		l = 0
		for _, e := range m.Longs {
			l += sovTalaria(uint64(e))
		}
		n += 1 + sovTalaria(uint64(l)) + l
	}
	return n
}

func (m *ColumnOfFloat64) Size() (n int) {
	var l int
	_ = l
	if len(m.Nulls) > 0 {
		n += 1 + sovTalaria(uint64(len(m.Nulls))) + len(m.Nulls)*1
	}
	if len(m.Doubles) > 0 {
		n += 1 + sovTalaria(uint64(len(m.Doubles)*8)) + len(m.Doubles)*8
	}
	return n
}

func (m *ColumnOfBools) Size() (n int) {
	var l int
	_ = l
	if len(m.Nulls) > 0 {
		n += 1 + sovTalaria(uint64(len(m.Nulls))) + len(m.Nulls)*1
	}
	if len(m.Bools) > 0 {
		n += 1 + sovTalaria(uint64(len(m.Bools))) + len(m.Bools)*1
	}
	return n
}

func (m *ColumnOfString) Size() (n int) {
	var l int
	_ = l
	if len(m.Nulls) > 0 {
		n += 1 + sovTalaria(uint64(len(m.Nulls))) + len(m.Nulls)*1
	}
	if len(m.Sizes) > 0 {
		l = 0
		for _, e := range m.Sizes {
			l += sovTalaria(uint64(e))
		}
		n += 1 + sovTalaria(uint64(l)) + l
	}
	l = len(m.Bytes)
	if l > 0 {
		n += 1 + l + sovTalaria(uint64(l))
	}
	return n
}

func sovTalaria(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozTalaria(x uint64) (n int) {
	return sovTalaria(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *IngestRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&IngestRequest{`,
		`Data:` + fmt.Sprintf("%v", this.Data) + `,`,
		`}`,
	}, "")
	return s
}
func (this *IngestRequest_Batch) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&IngestRequest_Batch{`,
		`Batch:` + strings.Replace(fmt.Sprintf("%v", this.Batch), "Batch", "Batch", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *IngestRequest_Orc) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&IngestRequest_Orc{`,
		`Orc:` + fmt.Sprintf("%v", this.Orc) + `,`,
		`}`,
	}, "")
	return s
}
func (this *IngestResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&IngestResponse{`,
		`}`,
	}, "")
	return s
}
func (this *Batch) String() string {
	if this == nil {
		return "nil"
	}
	keysForStrings := make([]uint32, 0, len(this.Strings))
	for k, _ := range this.Strings {
		keysForStrings = append(keysForStrings, k)
	}
	github_com_gogo_protobuf_sortkeys.Uint32s(keysForStrings)
	mapStringForStrings := "map[uint32][]byte{"
	for _, k := range keysForStrings {
		mapStringForStrings += fmt.Sprintf("%v: %v,", k, this.Strings[k])
	}
	mapStringForStrings += "}"
	s := strings.Join([]string{`&Batch{`,
		`Strings:` + mapStringForStrings + `,`,
		`Events:` + strings.Replace(fmt.Sprintf("%v", this.Events), "Event", "Event", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Event) String() string {
	if this == nil {
		return "nil"
	}
	keysForValue := make([]uint32, 0, len(this.Value))
	for k, _ := range this.Value {
		keysForValue = append(keysForValue, k)
	}
	github_com_gogo_protobuf_sortkeys.Uint32s(keysForValue)
	mapStringForValue := "map[uint32]*Value{"
	for _, k := range keysForValue {
		mapStringForValue += fmt.Sprintf("%v: %v,", k, this.Value[k])
	}
	mapStringForValue += "}"
	s := strings.Join([]string{`&Event{`,
		`Value:` + mapStringForValue + `,`,
		`}`,
	}, "")
	return s
}
func (this *Value) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Value{`,
		`Value:` + fmt.Sprintf("%v", this.Value) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Value_Int32) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Value_Int32{`,
		`Int32:` + fmt.Sprintf("%v", this.Int32) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Value_Int64) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Value_Int64{`,
		`Int64:` + fmt.Sprintf("%v", this.Int64) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Value_Float64) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Value_Float64{`,
		`Float64:` + fmt.Sprintf("%v", this.Float64) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Value_String_) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Value_String_{`,
		`String_:` + fmt.Sprintf("%v", this.String_) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Value_Bool) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Value_Bool{`,
		`Bool:` + fmt.Sprintf("%v", this.Bool) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Value_Time) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Value_Time{`,
		`Time:` + fmt.Sprintf("%v", this.Time) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Value_Json) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Value_Json{`,
		`Json:` + fmt.Sprintf("%v", this.Json) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DescribeRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DescribeRequest{`,
		`}`,
	}, "")
	return s
}
func (this *DescribeResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DescribeResponse{`,
		`Tables:` + strings.Replace(fmt.Sprintf("%v", this.Tables), "TableMeta", "TableMeta", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *TableMeta) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TableMeta{`,
		`Schema:` + fmt.Sprintf("%v", this.Schema) + `,`,
		`Table:` + fmt.Sprintf("%v", this.Table) + `,`,
		`Columns:` + strings.Replace(fmt.Sprintf("%v", this.Columns), "ColumnMeta", "ColumnMeta", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ColumnMeta) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ColumnMeta{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`Comment:` + fmt.Sprintf("%v", this.Comment) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSplitsRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSplitsRequest{`,
		`Schema:` + fmt.Sprintf("%v", this.Schema) + `,`,
		`Table:` + fmt.Sprintf("%v", this.Table) + `,`,
		`Columns:` + fmt.Sprintf("%v", this.Columns) + `,`,
		`Filters:` + fmt.Sprintf("%v", this.Filters) + `,`,
		`MaxSplits:` + fmt.Sprintf("%v", this.MaxSplits) + `,`,
		`NextToken:` + fmt.Sprintf("%v", this.NextToken) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSplitsResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSplitsResponse{`,
		`Splits:` + strings.Replace(fmt.Sprintf("%v", this.Splits), "Split", "Split", 1) + `,`,
		`NextToken:` + fmt.Sprintf("%v", this.NextToken) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Endpoint) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Endpoint{`,
		`Host:` + fmt.Sprintf("%v", this.Host) + `,`,
		`Port:` + fmt.Sprintf("%v", this.Port) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Split) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Split{`,
		`SplitID:` + fmt.Sprintf("%v", this.SplitID) + `,`,
		`Hosts:` + strings.Replace(fmt.Sprintf("%v", this.Hosts), "Endpoint", "Endpoint", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetRowsRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetRowsRequest{`,
		`SplitID:` + fmt.Sprintf("%v", this.SplitID) + `,`,
		`Columns:` + fmt.Sprintf("%v", this.Columns) + `,`,
		`MaxBytes:` + fmt.Sprintf("%v", this.MaxBytes) + `,`,
		`NextToken:` + fmt.Sprintf("%v", this.NextToken) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetRowsResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetRowsResponse{`,
		`Columns:` + strings.Replace(fmt.Sprintf("%v", this.Columns), "Column", "Column", 1) + `,`,
		`RowCount:` + fmt.Sprintf("%v", this.RowCount) + `,`,
		`NextToken:` + fmt.Sprintf("%v", this.NextToken) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Column) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Column{`,
		`Value:` + fmt.Sprintf("%v", this.Value) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Column_Int32) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Column_Int32{`,
		`Int32:` + strings.Replace(fmt.Sprintf("%v", this.Int32), "ColumnOfInt32", "ColumnOfInt32", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Column_Int64) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Column_Int64{`,
		`Int64:` + strings.Replace(fmt.Sprintf("%v", this.Int64), "ColumnOfInt64", "ColumnOfInt64", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Column_Float64) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Column_Float64{`,
		`Float64:` + strings.Replace(fmt.Sprintf("%v", this.Float64), "ColumnOfFloat64", "ColumnOfFloat64", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Column_String_) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Column_String_{`,
		`String_:` + strings.Replace(fmt.Sprintf("%v", this.String_), "ColumnOfString", "ColumnOfString", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Column_Bool) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Column_Bool{`,
		`Bool:` + strings.Replace(fmt.Sprintf("%v", this.Bool), "ColumnOfBools", "ColumnOfBools", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Column_Time) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Column_Time{`,
		`Time:` + strings.Replace(fmt.Sprintf("%v", this.Time), "ColumnOfInt64", "ColumnOfInt64", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Column_Json) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Column_Json{`,
		`Json:` + strings.Replace(fmt.Sprintf("%v", this.Json), "ColumnOfString", "ColumnOfString", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ColumnOfInt32) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ColumnOfInt32{`,
		`Nulls:` + fmt.Sprintf("%v", this.Nulls) + `,`,
		`Ints:` + fmt.Sprintf("%v", this.Ints) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ColumnOfInt64) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ColumnOfInt64{`,
		`Nulls:` + fmt.Sprintf("%v", this.Nulls) + `,`,
		`Longs:` + fmt.Sprintf("%v", this.Longs) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ColumnOfFloat64) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ColumnOfFloat64{`,
		`Nulls:` + fmt.Sprintf("%v", this.Nulls) + `,`,
		`Doubles:` + fmt.Sprintf("%v", this.Doubles) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ColumnOfBools) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ColumnOfBools{`,
		`Nulls:` + fmt.Sprintf("%v", this.Nulls) + `,`,
		`Bools:` + fmt.Sprintf("%v", this.Bools) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ColumnOfString) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ColumnOfString{`,
		`Nulls:` + fmt.Sprintf("%v", this.Nulls) + `,`,
		`Sizes:` + fmt.Sprintf("%v", this.Sizes) + `,`,
		`Bytes:` + fmt.Sprintf("%v", this.Bytes) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringTalaria(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *IngestRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTalaria
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IngestRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IngestRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Batch", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTalaria
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTalaria
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Batch{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Data = &IngestRequest_Batch{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Orc", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTalaria
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTalaria
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := make([]byte, postIndex-iNdEx)
			copy(v, dAtA[iNdEx:postIndex])
			m.Data = &IngestRequest_Orc{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTalaria(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTalaria
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IngestResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTalaria
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IngestResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IngestResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTalaria(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTalaria
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Batch) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTalaria
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Batch: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Batch: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Strings", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTalaria
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTalaria
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTalaria
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var mapkey uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTalaria
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				mapkey |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if m.Strings == nil {
				m.Strings = make(map[uint32][]byte)
			}
			if iNdEx < postIndex {
				var valuekey uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTalaria
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					valuekey |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				var mapbyteLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTalaria
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					mapbyteLen |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intMapbyteLen := int(mapbyteLen)
				if intMapbyteLen < 0 {
					return ErrInvalidLengthTalaria
				}
				postbytesIndex := iNdEx + intMapbyteLen
				if postbytesIndex > l {
					return io.ErrUnexpectedEOF
				}
				mapvalue := make([]byte, mapbyteLen)
				copy(mapvalue, dAtA[iNdEx:postbytesIndex])
				iNdEx = postbytesIndex
				m.Strings[mapkey] = mapvalue
			} else {
				var mapvalue []byte
				m.Strings[mapkey] = mapvalue
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Events", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTalaria
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTalaria
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Events = append(m.Events, &Event{})
			if err := m.Events[len(m.Events)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTalaria(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTalaria
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Event) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTalaria
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Event: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Event: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTalaria
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTalaria
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTalaria
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var mapkey uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTalaria
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				mapkey |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if m.Value == nil {
				m.Value = make(map[uint32]*Value)
			}
			if iNdEx < postIndex {
				var valuekey uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTalaria
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					valuekey |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				var mapmsglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTalaria
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					mapmsglen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if mapmsglen < 0 {
					return ErrInvalidLengthTalaria
				}
				postmsgIndex := iNdEx + mapmsglen
				if mapmsglen < 0 {
					return ErrInvalidLengthTalaria
				}
				if postmsgIndex > l {
					return io.ErrUnexpectedEOF
				}
				mapvalue := &Value{}
				if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
					return err
				}
				iNdEx = postmsgIndex
				m.Value[mapkey] = mapvalue
			} else {
				var mapvalue *Value
				m.Value[mapkey] = mapvalue
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTalaria(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTalaria
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Value) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTalaria
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Value: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Value: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Int32", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTalaria
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Value = &Value_Int32{v}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Int64", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTalaria
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Value = &Value_Int64{v}
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Float64", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.Value = &Value_Float64{float64(math.Float64frombits(v))}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field String_", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTalaria
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Value = &Value_String_{v}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bool", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTalaria
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Value = &Value_Bool{b}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTalaria
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Value = &Value_Time{v}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Json", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTalaria
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Value = &Value_Json{v}
		default:
			iNdEx = preIndex
			skippy, err := skipTalaria(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTalaria
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DescribeRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTalaria
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DescribeRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DescribeRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTalaria(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTalaria
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DescribeResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTalaria
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DescribeResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DescribeResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tables", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTalaria
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTalaria
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tables = append(m.Tables, &TableMeta{})
			if err := m.Tables[len(m.Tables)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTalaria(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTalaria
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TableMeta) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTalaria
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TableMeta: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TableMeta: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Schema", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTalaria
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTalaria
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Schema = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Table", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTalaria
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTalaria
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Table = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Columns", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTalaria
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTalaria
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Columns = append(m.Columns, &ColumnMeta{})
			if err := m.Columns[len(m.Columns)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTalaria(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTalaria
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ColumnMeta) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTalaria
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ColumnMeta: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ColumnMeta: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTalaria
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTalaria
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTalaria
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTalaria
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Comment", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTalaria
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTalaria
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Comment = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTalaria(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTalaria
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetSplitsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTalaria
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetSplitsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetSplitsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Schema", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTalaria
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTalaria
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Schema = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Table", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTalaria
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTalaria
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Table = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Columns", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTalaria
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTalaria
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Columns = append(m.Columns, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Filters", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTalaria
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTalaria
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Filters = append(m.Filters, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxSplits", wireType)
			}
			m.MaxSplits = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTalaria
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxSplits |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextToken", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTalaria
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTalaria
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NextToken = append(m.NextToken[:0], dAtA[iNdEx:postIndex]...)
			if m.NextToken == nil {
				m.NextToken = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTalaria(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTalaria
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetSplitsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTalaria
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetSplitsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetSplitsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Splits", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTalaria
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTalaria
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Splits = append(m.Splits, &Split{})
			if err := m.Splits[len(m.Splits)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextToken", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTalaria
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTalaria
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NextToken = append(m.NextToken[:0], dAtA[iNdEx:postIndex]...)
			if m.NextToken == nil {
				m.NextToken = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTalaria(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTalaria
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Endpoint) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTalaria
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Endpoint: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Endpoint: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Host", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTalaria
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTalaria
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Host = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Port", wireType)
			}
			m.Port = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTalaria
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Port |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTalaria(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTalaria
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Split) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTalaria
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Split: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Split: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SplitID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTalaria
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTalaria
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SplitID = append(m.SplitID[:0], dAtA[iNdEx:postIndex]...)
			if m.SplitID == nil {
				m.SplitID = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hosts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTalaria
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTalaria
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hosts = append(m.Hosts, &Endpoint{})
			if err := m.Hosts[len(m.Hosts)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTalaria(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTalaria
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetRowsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTalaria
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetRowsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetRowsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SplitID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTalaria
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTalaria
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SplitID = append(m.SplitID[:0], dAtA[iNdEx:postIndex]...)
			if m.SplitID == nil {
				m.SplitID = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Columns", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTalaria
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTalaria
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Columns = append(m.Columns, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxBytes", wireType)
			}
			m.MaxBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTalaria
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxBytes |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextToken", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTalaria
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTalaria
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NextToken = append(m.NextToken[:0], dAtA[iNdEx:postIndex]...)
			if m.NextToken == nil {
				m.NextToken = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTalaria(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTalaria
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetRowsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTalaria
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetRowsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetRowsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Columns", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTalaria
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTalaria
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Columns = append(m.Columns, &Column{})
			if err := m.Columns[len(m.Columns)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RowCount", wireType)
			}
			m.RowCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTalaria
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RowCount |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextToken", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTalaria
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTalaria
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NextToken = append(m.NextToken[:0], dAtA[iNdEx:postIndex]...)
			if m.NextToken == nil {
				m.NextToken = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTalaria(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTalaria
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Column) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTalaria
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Column: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Column: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Int32", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTalaria
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTalaria
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ColumnOfInt32{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &Column_Int32{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Int64", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTalaria
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTalaria
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ColumnOfInt64{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &Column_Int64{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Float64", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTalaria
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTalaria
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ColumnOfFloat64{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &Column_Float64{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field String_", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTalaria
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTalaria
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ColumnOfString{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &Column_String_{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bool", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTalaria
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTalaria
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ColumnOfBools{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &Column_Bool{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTalaria
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTalaria
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ColumnOfInt64{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &Column_Time{v}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Json", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTalaria
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTalaria
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ColumnOfString{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &Column_Json{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTalaria(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTalaria
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ColumnOfInt32) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTalaria
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ColumnOfInt32: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ColumnOfInt32: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTalaria
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Nulls = append(m.Nulls, bool(v != 0))
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTalaria
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTalaria
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTalaria
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Nulls = append(m.Nulls, bool(v != 0))
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Nulls", wireType)
			}
		case 2:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTalaria
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Ints = append(m.Ints, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTalaria
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTalaria
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTalaria
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Ints = append(m.Ints, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Ints", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTalaria(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTalaria
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ColumnOfInt64) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTalaria
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ColumnOfInt64: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ColumnOfInt64: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTalaria
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Nulls = append(m.Nulls, bool(v != 0))
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTalaria
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTalaria
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTalaria
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Nulls = append(m.Nulls, bool(v != 0))
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Nulls", wireType)
			}
		case 2:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTalaria
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Longs = append(m.Longs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTalaria
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTalaria
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTalaria
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Longs = append(m.Longs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Longs", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTalaria(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTalaria
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ColumnOfFloat64) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTalaria
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ColumnOfFloat64: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ColumnOfFloat64: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTalaria
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Nulls = append(m.Nulls, bool(v != 0))
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTalaria
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTalaria
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTalaria
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Nulls = append(m.Nulls, bool(v != 0))
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Nulls", wireType)
			}
		case 2:
			if wireType == 1 {
				var v uint64
				if (iNdEx + 8) > l {
					return io.ErrUnexpectedEOF
				}
				iNdEx += 8
				v = uint64(dAtA[iNdEx-8])
				v |= uint64(dAtA[iNdEx-7]) << 8
				v |= uint64(dAtA[iNdEx-6]) << 16
				v |= uint64(dAtA[iNdEx-5]) << 24
				v |= uint64(dAtA[iNdEx-4]) << 32
				v |= uint64(dAtA[iNdEx-3]) << 40
				v |= uint64(dAtA[iNdEx-2]) << 48
				v |= uint64(dAtA[iNdEx-1]) << 56
				v2 := float64(math.Float64frombits(v))
				m.Doubles = append(m.Doubles, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTalaria
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTalaria
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint64
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					iNdEx += 8
					v = uint64(dAtA[iNdEx-8])
					v |= uint64(dAtA[iNdEx-7]) << 8
					v |= uint64(dAtA[iNdEx-6]) << 16
					v |= uint64(dAtA[iNdEx-5]) << 24
					v |= uint64(dAtA[iNdEx-4]) << 32
					v |= uint64(dAtA[iNdEx-3]) << 40
					v |= uint64(dAtA[iNdEx-2]) << 48
					v |= uint64(dAtA[iNdEx-1]) << 56
					v2 := float64(math.Float64frombits(v))
					m.Doubles = append(m.Doubles, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Doubles", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTalaria(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTalaria
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ColumnOfBools) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTalaria
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ColumnOfBools: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ColumnOfBools: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTalaria
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Nulls = append(m.Nulls, bool(v != 0))
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTalaria
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTalaria
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTalaria
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Nulls = append(m.Nulls, bool(v != 0))
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Nulls", wireType)
			}
		case 2:
			if wireType == 0 {
				var v int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTalaria
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Bools = append(m.Bools, bool(v != 0))
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTalaria
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTalaria
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTalaria
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Bools = append(m.Bools, bool(v != 0))
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Bools", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTalaria(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTalaria
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ColumnOfString) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTalaria
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ColumnOfString: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ColumnOfString: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTalaria
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Nulls = append(m.Nulls, bool(v != 0))
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTalaria
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTalaria
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTalaria
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Nulls = append(m.Nulls, bool(v != 0))
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Nulls", wireType)
			}
		case 2:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTalaria
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Sizes = append(m.Sizes, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTalaria
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTalaria
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTalaria
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Sizes = append(m.Sizes, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Sizes", wireType)
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bytes", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTalaria
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTalaria
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Bytes = append(m.Bytes[:0], dAtA[iNdEx:postIndex]...)
			if m.Bytes == nil {
				m.Bytes = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTalaria(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTalaria
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTalaria(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTalaria
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTalaria
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTalaria
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthTalaria
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowTalaria
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipTalaria(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthTalaria = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTalaria   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("talaria.proto", fileDescriptorTalaria) }

var fileDescriptorTalaria = []byte{
	// 1033 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x56, 0x4d, 0x6f, 0x23, 0x35,
	0x18, 0x1e, 0x27, 0x99, 0x49, 0xf2, 0xf6, 0xdb, 0x54, 0xed, 0x6c, 0x40, 0xa3, 0x6a, 0x84, 0x4a,
	0x41, 0xdd, 0x20, 0xb2, 0xa5, 0x82, 0x5d, 0x69, 0xa5, 0xcd, 0xb6, 0xbb, 0x29, 0x12, 0x20, 0xdc,
	0x15, 0x12, 0xc7, 0x69, 0xea, 0xb6, 0xc3, 0x4e, 0xc6, 0x61, 0xec, 0x74, 0x1b, 0x0e, 0x08, 0xf1,
	0x0b, 0xf8, 0x0d, 0x9c, 0x38, 0x72, 0xe4, 0x27, 0x70, 0xec, 0x91, 0x23, 0x0d, 0x42, 0xe2, 0xb8,
	0x3f, 0x01, 0xd9, 0x1e, 0xcf, 0x57, 0x9b, 0x95, 0xb8, 0xf9, 0x79, 0xbf, 0x9e, 0xd7, 0xaf, 0xed,
	0x67, 0x06, 0x96, 0x44, 0x10, 0x05, 0x49, 0x18, 0x74, 0xc7, 0x09, 0x13, 0x0c, 0x37, 0x53, 0xe8,
	0x1f, 0xc3, 0xd2, 0x51, 0x7c, 0x4e, 0xb9, 0x20, 0xf4, 0xbb, 0x09, 0xe5, 0x02, 0x6f, 0x83, 0x7d,
	0x12, 0x88, 0xe1, 0x85, 0x8b, 0xb6, 0xd0, 0xce, 0x42, 0x6f, 0xb9, 0x6b, 0x12, 0xfb, 0xd2, 0x3a,
	0xb0, 0x88, 0x76, 0x63, 0x0c, 0x75, 0x96, 0x0c, 0xdd, 0xda, 0x16, 0xda, 0x59, 0x1c, 0x58, 0x44,
	0x82, 0xbe, 0x03, 0x8d, 0xd3, 0x40, 0x04, 0xfe, 0x2a, 0x2c, 0x9b, 0xa2, 0x7c, 0xcc, 0x62, 0x4e,
	0xfd, 0x5f, 0x10, 0xd8, 0xaa, 0x00, 0xfe, 0x18, 0x9a, 0x5c, 0x24, 0x61, 0x7c, 0xce, 0x5d, 0xb4,
	0x55, 0xdf, 0x59, 0xe8, 0xbd, 0x5d, 0x66, 0xe8, 0x1e, 0x6b, 0xef, 0x61, 0x2c, 0x92, 0x29, 0x31,
	0xb1, 0x78, 0x1b, 0x1c, 0x7a, 0x49, 0x63, 0xc1, 0xdd, 0x9a, 0xca, 0xca, 0xfb, 0x3a, 0x94, 0x66,
	0x92, 0x7a, 0x3b, 0x0f, 0x61, 0xb1, 0x58, 0x00, 0xaf, 0x42, 0xfd, 0x25, 0x9d, 0xaa, 0xcd, 0x2c,
	0x11, 0xb9, 0xc4, 0xeb, 0x60, 0x5f, 0x06, 0xd1, 0x84, 0xea, 0xd6, 0x89, 0x06, 0x0f, 0x6b, 0x9f,
	0x20, 0xff, 0x27, 0x04, 0xb6, 0xaa, 0x86, 0x3f, 0x34, 0x31, 0xba, 0xc5, 0x7b, 0x65, 0xb2, 0xee,
	0xd7, 0xd2, 0xa7, 0x1b, 0xd4, 0x71, 0x9d, 0x01, 0x40, 0x6e, 0xbc, 0x83, 0xf4, 0xdd, 0x22, 0x69,
	0xb1, 0x7b, 0x95, 0x55, 0x6c, 0xe2, 0x77, 0x04, 0xb6, 0x32, 0xe2, 0x0d, 0xb0, 0xc3, 0x58, 0x3c,
	0xe8, 0xa9, 0x3a, 0xb6, 0x9c, 0xbc, 0x82, 0xa9, 0x7d, 0x7f, 0x4f, 0xd5, 0xaa, 0xa7, 0xf6, 0xfd,
	0x3d, 0xdc, 0x81, 0xe6, 0x59, 0xc4, 0x02, 0xe9, 0xa9, 0x6f, 0xa1, 0x1d, 0x34, 0xb0, 0x88, 0x31,
	0x60, 0x17, 0x1c, 0x3d, 0x49, 0xb7, 0x21, 0x9b, 0x1a, 0x58, 0x24, 0xc5, 0x78, 0x1d, 0x1a, 0x27,
	0x8c, 0x45, 0xae, 0xbd, 0x85, 0x76, 0x5a, 0x03, 0x8b, 0x28, 0x24, 0xad, 0x22, 0x1c, 0x51, 0xd7,
	0x49, 0x29, 0x14, 0x92, 0xd6, 0x6f, 0x39, 0x8b, 0xdd, 0x66, 0x5a, 0x43, 0xa1, 0x7e, 0x33, 0xdd,
	0x9b, 0xbf, 0x06, 0x2b, 0x07, 0x94, 0x0f, 0x93, 0xf0, 0x84, 0xa6, 0xb7, 0xc9, 0x7f, 0x0c, 0xab,
	0xb9, 0x49, 0xdf, 0x05, 0xfc, 0x01, 0x38, 0x22, 0x38, 0x89, 0xa8, 0xb9, 0x00, 0x38, 0x1b, 0xc6,
	0x0b, 0x69, 0xfe, 0x9c, 0x8a, 0x80, 0xa4, 0x11, 0xfe, 0x05, 0xb4, 0x33, 0x23, 0xde, 0x00, 0x87,
	0x0f, 0x2f, 0xe8, 0x28, 0x50, 0x13, 0x69, 0x93, 0x14, 0xc9, 0x13, 0x55, 0xe1, 0x6a, 0x20, 0x6d,
	0xa2, 0x01, 0xbe, 0x0f, 0xcd, 0x21, 0x8b, 0x26, 0xa3, 0x98, 0xbb, 0x75, 0xc5, 0xf3, 0x56, 0xc6,
	0xf3, 0x54, 0xd9, 0x15, 0x91, 0x89, 0xf1, 0xbf, 0x00, 0xc8, 0xcd, 0x18, 0x43, 0x23, 0x0e, 0x46,
	0x34, 0x25, 0x52, 0x6b, 0x69, 0x13, 0xd3, 0xb1, 0x61, 0x51, 0x6b, 0xec, 0x4a, 0x92, 0xd1, 0x88,
	0xc6, 0x42, 0xcd, 0xbc, 0x4d, 0x0c, 0xf4, 0x7f, 0x43, 0xb0, 0xfa, 0x9c, 0x8a, 0xe3, 0x71, 0x14,
	0x0a, 0x6e, 0x1e, 0xd7, 0xff, 0xdb, 0x81, 0x5b, 0xde, 0x41, 0x3b, 0x6b, 0x56, 0x7a, 0xce, 0xc2,
	0x48, 0xd0, 0x84, 0xbb, 0x0d, 0xed, 0x49, 0x21, 0x7e, 0x07, 0xda, 0xa3, 0xe0, 0x4a, 0xb3, 0xaa,
	0x33, 0xb5, 0x49, 0x6e, 0x90, 0xde, 0x98, 0x5e, 0x89, 0x17, 0xec, 0x25, 0x8d, 0xd5, 0xd9, 0x2e,
	0x92, 0xdc, 0xe0, 0x7f, 0x03, 0x6b, 0x85, 0x8e, 0xd3, 0xd3, 0xda, 0x06, 0x87, 0xeb, 0x6a, 0xa8,
	0xf2, 0xf0, 0x54, 0x20, 0x49, 0xbd, 0xe5, 0xd2, 0xb5, 0x6a, 0xe9, 0x1e, 0xb4, 0x0e, 0xe3, 0xd3,
	0x31, 0x0b, 0x63, 0x21, 0xe7, 0x78, 0xc1, 0xb8, 0x30, 0xb3, 0x95, 0x6b, 0x69, 0x1b, 0xb3, 0x44,
	0xa8, 0x44, 0x9b, 0xa8, 0xb5, 0xff, 0x19, 0xd8, 0x8a, 0x42, 0xee, 0x56, 0x91, 0x1c, 0x1d, 0xa8,
	0x9c, 0x45, 0x62, 0x20, 0x7e, 0x0f, 0x6c, 0x99, 0x6e, 0x44, 0x61, 0x2d, 0x7f, 0xa7, 0x29, 0x19,
	0xd1, 0x7e, 0xff, 0x07, 0x58, 0x7e, 0x4e, 0x05, 0x61, 0xaf, 0xb2, 0xa3, 0x98, 0x5f, 0xb4, 0x30,
	0xf6, 0x5a, 0x79, 0xec, 0x1d, 0x68, 0x8d, 0x82, 0xab, 0xfe, 0x54, 0x50, 0xae, 0x8e, 0xbb, 0x4e,
	0x32, 0x5c, 0xde, 0x7f, 0xa3, 0xba, 0xff, 0x4b, 0x58, 0xc9, 0xf8, 0xd3, 0xc1, 0xbe, 0x9f, 0xd3,
	0xe8, 0xc9, 0xae, 0x54, 0xee, 0x67, 0x89, 0x37, 0x61, 0xaf, 0x9e, 0xb2, 0x49, 0x6c, 0x26, 0x94,
	0xe1, 0x32, 0x6f, 0xbd, 0xca, 0xfb, 0x4f, 0x0d, 0x1c, 0x5d, 0x0d, 0x77, 0x8b, 0x72, 0xb2, 0xd0,
	0xdb, 0xa8, 0xb0, 0x7d, 0x79, 0x76, 0x24, 0xbd, 0xb9, 0xcc, 0x74, 0x8b, 0x32, 0x33, 0x27, 0x7e,
	0x7f, 0x2f, 0x97, 0x9f, 0xbd, 0xb2, 0xfc, 0x2c, 0xf4, 0xdc, 0x5b, 0x19, 0xcf, 0xb4, 0xbf, 0x28,
	0x4c, 0x1f, 0x95, 0x84, 0x69, 0xa1, 0xb7, 0x79, 0x2b, 0x49, 0xcb, 0x79, 0x41, 0xb1, 0x76, 0x0b,
	0x8a, 0x75, 0x57, 0x5f, 0x7d, 0xc6, 0x22, 0x9e, 0x29, 0xd9, 0x6e, 0x41, 0xc9, 0xde, 0xb4, 0x0b,
	0xad, 0x70, 0xf7, 0x0b, 0x0a, 0xf7, 0xc6, 0x66, 0x2a, 0xd2, 0xf7, 0x29, 0x2c, 0x95, 0xc6, 0x28,
	0x5f, 0x74, 0x3c, 0x89, 0x22, 0x7d, 0xb6, 0x2d, 0xa2, 0x81, 0xbc, 0xe6, 0xa1, 0xf9, 0x86, 0xd9,
	0x44, 0xad, 0xfd, 0x47, 0xa5, 0xd4, 0xfd, 0xbd, 0x39, 0xa9, 0xeb, 0x60, 0x47, 0x4c, 0x7e, 0x35,
	0x65, 0x6e, 0x9d, 0x68, 0xe0, 0x3f, 0x81, 0x95, 0xca, 0x70, 0xe7, 0xa4, 0xbb, 0xd0, 0x3c, 0x65,
	0x13, 0xa5, 0xba, 0xb2, 0x00, 0x22, 0x06, 0x16, 0xf9, 0xd5, 0xe4, 0xe6, 0xf3, 0xcb, 0x79, 0xea,
	0xf4, 0x16, 0xd1, 0xc0, 0x27, 0xb0, 0x5c, 0x1e, 0xcd, 0xfc, 0x6c, 0x1e, 0x7e, 0x4f, 0xcd, 0xce,
	0x35, 0x50, 0x35, 0xb3, 0xc7, 0xb4, 0x48, 0x34, 0xe8, 0x3d, 0x83, 0xe6, 0x51, 0x7c, 0x9e, 0x50,
	0xce, 0xf1, 0x23, 0x70, 0xf4, 0x8f, 0x04, 0xce, 0x0f, 0xae, 0xf4, 0xbb, 0xd2, 0xd9, 0xbc, 0x65,
	0x4f, 0xff, 0x38, 0xac, 0xde, 0x35, 0x02, 0xfb, 0xab, 0x09, 0x4d, 0xa6, 0xf8, 0x09, 0xb4, 0xcc,
	0x57, 0x08, 0xe7, 0xb7, 0xb2, 0xf2, 0xad, 0xea, 0xdc, 0xbb, 0xc3, 0x63, 0x8a, 0xe1, 0x03, 0x68,
	0x67, 0xda, 0x88, 0xf3, 0xc8, 0xaa, 0xc2, 0x77, 0x3a, 0x77, 0xb9, 0xb2, 0x2a, 0x8f, 0xa1, 0x99,
	0xca, 0x00, 0xde, 0x2c, 0x06, 0x16, 0x84, 0xa9, 0xe3, 0xde, 0x76, 0x98, 0xfc, 0xfe, 0xee, 0xf5,
	0x8d, 0x67, 0xfd, 0x79, 0xe3, 0x59, 0xaf, 0x6f, 0x3c, 0xf4, 0xe3, 0xcc, 0x43, 0xbf, 0xce, 0x3c,
	0xf4, 0xc7, 0xcc, 0x43, 0xd7, 0x33, 0x0f, 0xfd, 0x35, 0xf3, 0xd0, 0xbf, 0x33, 0xcf, 0x7a, 0x3d,
	0xf3, 0xd0, 0xcf, 0x7f, 0x7b, 0xd6, 0x89, 0xa3, 0xfe, 0xf5, 0x1e, 0xfc, 0x17, 0x00, 0x00, 0xff,
	0xff, 0xd2, 0xe6, 0x4c, 0x9c, 0xfc, 0x09, 0x00, 0x00,
}
